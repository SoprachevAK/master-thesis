
#import "/utils/setup.typ": fig

= Постановка задачи
Задачей проекта является продолжить развитие приложение PolyMap@PolyMap. Необходимо разработать универсальный вариант приложения, позволяющий отображать различные карты разных заказчиков. Так же приложение должно работать в браузерном режиме и предоставляться в виде SaaS@SaaS (Software as a Service).

= Актуальность работы
Актуальность работы обусловлена тем, что существующие решения не позволяют отображать карты разных заказчиков в одном приложении. Так же существующие решения не позволяют отображать карты в браузерном режиме.
Проблема навигации в пешеходной среде является актуальной для многих публичных мест. Приложение PolyMap крайне хорошо справляется с этой задачей, и обладает высокими статистическими показателями.

== Статистика PolyMap
Согласно Yandex App Metrica@appmetrica, еженедельное число пользователей приложения PolyMap (@total) составляет 4-5 тысяч уникальных человек. При этом пик поиска аннотаций приходится на начало сентября: 3 тысячи пользователей (@users) просматривали аннотации 27 тысяч раз (@events) в неделю с 4 по 10 сентября.

Это говорит о том, что приложение PolyMap пользуется спросом у пользователей, и имеет потенциал для развития.

#fig("Еженедельное количество пользователей PolyMap", "/images/polymap-users.png", width: 80%)[]<total>

#fig(
  "Еженедельное количество пользователей открывших информацию об аннотации",
  "/images/unit-detail.png",
)[]<users>

#fig("Еженедельное число открытий аннотаций", "/images/unit-detail-event.png")[]<events>

== Задачи для развития приложения PolyMap
Основной проблемой приложения PolyMap является то, что оно не универсально. Приложение PolyMap разработано для конкретного вуза, и не может быть использовано другими. Кроме того, приложение разработано только для операционной системы iOS, и не может быть использовано на других платформах.

Из этих проблем вытекают следующие задачи для развития приложения PolyMap:
1. Разработать универсальный вариант приложения, позволяющий отображать различные карты разных заказчиков.
2. Разработать удобный конструктор карт, позволяющий заказчикам создавать и обновлять карты самостоятельно.
3. Разработать веб-приложение способное отображать карту в браузере на любой платформе.

При разработке так же важно предусмотреть возможность масштабирования приложения под большие нагрузки.


= Подходы к решению задачи
Несмотря на кажущуюся простоту задачи, приложение PolyMap состоит из большого числа модулей, выполняющих разные задачи. Сейчас все серверные части PolyMap написаны с использованием монолитного подхода и развернуты на виртуальной машине. Это позволяет быстро разрабатывать и развивать приложение, но не позволяет масштабировать его под большие нагрузки.

Для решения задачи развития приложения PolyMap необходимо переписать серверную часть приложения с использованием микросервисной архитектуры. Это позволит разрабатывать и развивать приложение в дальнейшем, а так же масштабировать его под большие нагрузки.

При использование микросервисного подхода возникает ряд сложностей с оркестрацией и развертыванием приложения. Для решения этих проблем необходимо использовать контейнеризацию Docker@docker.
Для оркестрации контейнеров наиболее распространённым подходом является использование Kubernetes@kubernetes, однако этот подход требует больших затрат на поддержку, а так же требует написания специфичного кода. Для решения этих проблем можно использовать новый Serverless подход, который позволяет автоматизировать развертывание и поддержку приложения.


== Serverless подход
Serverless@serverless - это модель облачных вычислений, при которой облачный провайдер полностью управляет запуском и инфраструктурой сервера. Пользователи пишут только код приложения
Основными преимуществами Serverless подхода являются:

- Автомасштабирование. Сервис автоматически масштабируется в зависимости от нагрузки, без необходимости управления инфраструктурой
- Оплата по использованию (Pay-as-you-go). Пользователь платит только за реально использованные ресурсы
- Администрирование. Пользователь не заботится о настройке и обслуживании серверов, администрирование серверов полностью ложится на облачного провайдера. Снижает инфраструктурные риски и упрощает разработку приложения
- Быстрое развертывание. Приложение разворачивается в несколько кликов, без необходимости настройки серверов


=== Yandex Cloud

В качестве облачного провайдера для развёртывания приложения PolyMap была выбрана Yandex Cloud@YC. Yandex Cloud предоставляет полный набор инструментов для разработки и развёртывания Serverless приложений. Основными используемыми инструментами являются:
- Serverless Containers@YCONTENER. Позволяет разворачивать Docker контейнеры в облаке, и автоматически масштабировать их в зависимости от нагрузки
- API Gateway@YAPI. Позволяет создавать API для взаимодействия с приложением
- Yandex Object Storage@YOS. Облачное Serverless хранилище данных, используется для хранения статических файлов приложения по протоколу S3@S3
- Yandex Database@YDB. Облачная Serverless база данных, используется для хранения данных приложения по протоколу DynamoDB

Все эти инструменты позволяют разворачивать приложение в облаке, и автоматически масштабировать его в зависимости от нагрузки. При этом пользователь платит только за реально использованные ресурсы.
Потенциал горизонтального масштабирования неограничен, и позволяет разворачивать приложение на любое количество серверов. API Gateway балансирует нагрузку между Serverless контейнерами, и при стандартном подходе на каждый запрос создаётся новый контейнер.

== Общая архитектура приложения
При разработке высоконагруженных приложений необходимо использовать CDN (Content Delivery Network@cdn). CDN - это распределённая сеть серверов, которая позволяет ускорить доставку контента до конечного пользователя. Приложение PolyMap использует карты, которые имеют большой объём данных, и для ускорения их доставки необходимо использовать CDN.

В качестве CDN необходимо использовать провайдера с большим покрытием серверов, к сожалению у Yandex Cloud нет CDN. Поэтому в качестве CDN был выбран Cloudflare@cloudflare. Cloudflare имеет большое количество серверов по всему миру, и позволяет ускорить доставку контента до конечного пользователя.

#fig("Общая архитектура приложения PolyMap", "/images/y-serverless.png")[]

Когда фронтенд совершает запрос, он попадает на Cloudflare DNS, который определяет на какой сервер отправить запрос. В случае если запрос разрешает кеширование, то Cloudflare возвращает ответ из кеша без обращения к серверу. Если запрос не разрешает кеширование, то Cloudflare проксирует запрос на API Gateway в Яндексе. API Gateway балансирует нагрузку между Serverless контейнерами, образы которых хранятся в Container Registry. Контейнеры могут получать доступ к различным репозиториям данных, расположенным как в Serverless окружение, так и просто в облаке.

== Детальная архитектура приложения
Приложение состоит из следующих микросервисов:

+ Конструктор карты
  + `constructor-ws`: WebSocket@ws сервер, обеспечивает синхронизацию данных между пользователями при работе с одной картой\
  + `blobl-storage`: хранилище данных, используется для хранения больших пользоавтельских файлов при создании карты (например планироваки помещений)
  + `constructor-back`: бекенд, обеспечивает работу конструктора карт. Права доступа, авторизацию, сохранение и т.д.
+ `map-storage`: отвечает за хранение и раздачу карт
+ `share-back`: отвечает за генерацию коротких ссылок для приглашения пользователей в карту/маршрут/аннотацию
+ `qr-generator`: отвечает за генерацию QR кодов для приглашения
+ Поддержка веб-версии карты
  + `web-map-front`: раздаёт статические файлы для веб-версии карты
  + `web-map-back:`: динамически генерирует index.html для веб-версии карты, для корректной работы SEO оптимизации

#fig("Детальная архитектура приложения PolyMap", "/images/detail-arch.png")[]


= СI/CD
При использовании микросервисной архитектуры, крайне важно автоматизировать процесс развёртывания приложения, что позволит сильно ускорить процесс разработки. Для этого необходимо использовать CI/CD (Continuous Integration/Continuous Delivery) систему.
В качестве хостинга Git был выбран GitHub, из чего вытекает необходимость использовать GitHub Actions для CI/CD. GitHub Actions позволяет автоматизировать процесс развёртывания приложения, и выполнять различные действия при событиях в репозитории.


== Terraform

Terraform@terrafom - это инструмент для управления инфраструктурой как кодом (IaC - Infrastructure as Code @IaC). Он позволяет пользователям определять и создавать полную инфраструктуру в облаке с использованием высокоуровневого конфигурационного языка. Это означает, что описание инфраструктуры хранится в виде кода в репозитории, и может быть использовано для развёртывания и управления инфраструктурой.

Основными преимуществами Terraform являются:
- IaC: Terraform позволяет определять инфраструктуру с помощью кода, что обеспечивает более высокий уровень автоматизации, удобство отслеживания изменений, лучшее управление версиями и повторное использование кода
- Автоматизация Развертывания: С Terraform можно автоматически развертывать и обновлять серверные функции, API-интерфейсы и другие ресурсы, необходимые для serverless приложений.
- Модульность: Terraform позволяет создавать переиспользуемые модули
- Планирование Изменений: Terraform предоставляет детализированный план изменений перед их применением, что позволяет предвидеть и управлять последствиями изменений в инфраструктуре


#fig("Пример использования Terraform", "/images/terraform.png", width: 80%)[]


== Пайплайн в GitHub Actions
Наиболее популярные подходы к использованию Git@git подразумевают создание новых веток на каждую новую функциональность, и в момент завершения разработки функциональности создание Pull Request'a в основную ветку. После этого Pull Request проходит ряд проверок, и в случае успешного прохождения проверок, изменения из ветки сливаются в основную ветку.

Репозиторий расположен в GitHub, и используется GitHub Actions@ghActions для автоматизации процесса развёртывания приложения. GitHub Actions позволяет запускать различные действия при событиях в репозитории, таких как создание Pull Request'a, коммит в ветку и т.д.

Я использую подход GitFlow@gitflow, согласно которому создаются две основные ветки – main и dev, для текущей актуальной версии приложения и для разработки соответственно. Все новые функциональности разрабатываются в отдельных ветках, которые вливаются в ветку dev. После этого ветка dev вливается в ветку main, и выпускается новая версия приложения.

При таком подходе CI/CD система должна обрабатывать:
- Открытие Pull Request'a в ветку dev
  - запуск статического анализатор и тестов
  - проверка terraform конфигурации перед применением
- Коммит в ветку dev (принятие изменений в Pull Request'e автоматически создаёт коммит в ветку dev): сборка и развёртывание изменений в тестовом окружении
- Коммит в ветку main (принятие изменений в Pull Request'e автоматически создаёт коммит в ветку main): сборка и развёртывание изменений в продакшен окружении

=== Пайплайн для открытия Pull Request'a в ветку dev
Этот пайплайн срабатывает при открытие и изменение Pull Request'a. Благодаря использованию Serverless подхода, появляется возможность создавать НОВОЕ полностью изолированное окружение для каждого PullRequest'a. Это позволяет выполнять тестирование на реальной инфраструктуре при этом не конфликтуя с другими PullRequest'ами. Благодаря использованию Terraform, временная тестовое окружение будет полностью идентично продакшену, что позволит выявить большинство ошибок на ранних этапах разработки.

Состоит двух параллельных задач:

+ Сборка для тестового окружения:
  + Lint and Unit Tests: запускается линтер и юнит тесты для всех модулей приложения
  + Request Worker Folder: запрашивает новую директорию в Yandex Cloud для развёртывания тестового окружения
  + Clear comments: очищает старый автоматический комментарии в Pull Request'e
  + Terraform: выполняет развёртывание тестового окружения с помощью Terraform в указанной директории
  + E2E tests: запускает E2E тесты, передавая в качестве параметра URL до тестового окружения (генерируется автоматически Yandex Cloud)
  + Comment Deploy Link: создаёт комментарий в Pull Request'e с ссылкой на тестовое окружение для ручного тестирования
+ Подготовка к принятию изменений:
  + Clear comments: очищает старый автоматический комментарий в Pull Request'e
  + Terraform: выполняет команду `terraform plan` в продакшен режиме для подготовки к принятию изменений. Вывод команды печатается в комментарий в Pull Request'e


#fig("Пайплайн в GitHub Actions", "/images/gha.png")[]

В Yandex Cloud изолированные окружения внутри одной организации называются директориями, из-за ограничений облачного провайдера, процесс создание новой директории занимает около 5 минут. Для ускорения развёртывания тестового окружения, был использован подход с использованием пула директорий. Во время развёртывания тестового окружения, GitHub Actions запрашивает свободную директорию, если такой нет, то создаётся новая, иначе используется уже существующая. После принятия Pull Request'a, директория очищается и возвращается в пул свободных.

Статический анализатор и Unit тесты запускаются на первом шаге на основе исходного кода без необходимости использования инфраструктуры. Это позволяет быстро выявлять ошибки в коде, и не тратить время на развёртывание тестового окружения.
End-to-end@cypress тесты (REST запросы в случае бекенда, и UI тесты в случае фронтенда) запускаются на тестовом окружении, что позволяет проверить работу приложения в реальном окружении.

#fig("Отчёт о прохождение GitHub Actions", "/images/gh-report.png")[]

#fig("Комментарий в Pull Request'e", "/images/pr-comment.png", width: 80%)[]

После завершения пайплайна, в Pull Request'e создаётся комментарий с ссылкой на тестовое окружение, и выводом команды `terraform plan`. Это позволяет быстро проверить работу приложения, и убедиться в корректности изменений.
