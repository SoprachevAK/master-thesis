#import "../utils/utils.typ": fig, subfig, todo, listing

= Анализ предметной области

Проблема навигации по территориям и помещениям известна давно, и существует множество предложений по её решению. Глобально можно выделить два подхода к решению этой проблемы:
+ Аналоговый подход. В него входит улучшение офлайн-среды: установка указателей, информационных стендов, печатных карт, цветового кодирования и т.д.
+ Цифровой подход. Более продвинутый и современный способ, который лучше подходит для молодых поколений, привыкших к цифровым решениям. В него входит использование мобильных приложений, веб-сайтов, интерактивных стендов и т.д. Цифровые решения можно подразделить ещё на две категории, в зависимости от того, кем они разработаны:
  + Разработки крупных корпораций. Сюда относятся картографические приложения, такие как Google Maps, Яндекс.Карты, Apple Maps. Они ориентированы на массовую аудиторию и в первую очередь на навигацию городского уровня. Несмотря на то, что они поддерживают навигацию по отдельным зданиям, размещение карт по своему желанию в них невозможно. Корпорации сами выбирают, какие здания и территории будут отображаться на их картах. Кроме того, они крайне плохо поддерживают навигацию внутри зданий.
  + Разработки небольших стартапов. В отличие от корпораций, стартапы, наоборот, ориентированы на проблемы заказчиков и стараются предоставлять сервис для решения конкретных узких задач. В контексте разработки карт стартапы предлагают услуги по размещению интерактивных планировок зданий, и любой желающий заказчик может воспользоваться их услугами. Именно к этой категории относится проект PolyMap.

Для наиболее комфортной навигации оптимально использовать оба подхода, однако в современных условиях тотальной цифровизации новые поколения воспринимают цифровые решения как более удобные и привычные, нежели аналоговые.

== Обзор существующих решений
Несмотря на то, что платформа PolyMap относится к категории цифрового подхода стартапов, полезно рассмотреть предметную область в целом — это позволит оценить и перенять часть идей из смежных подходов.

=== Аналоговый подход
Аналоговый подход достаточно обширен: он начинается ещё на этапе планировки зданий и продолжается в процессе их эксплуатации. На этапе проектирования зданий необходимо продумать понятные коридоры, лестницы, выходы. Наиболее удобными являются прямоугольные, Т-образные и H-образные планировки, когда помещения строятся вокруг простых структур коридоров. Также важным фактором является возможность добраться до любого помещения на этаже, не покидая этот этаж, и правильная нумерация кабинетов, которая включает в себя номер этажа: например, кабинет #text(weight: "bold")[1]12 находится на первом этаже, а #text(weight: "bold")[2]12 — на втором.

К примерам хорошей планировки можно отнести Главное учебное здание СПбПУ, оно представляет классическую H-образную форму коридоров. Планировка здания на @main-building: белым цветом отображаются коридоры.

#fig(
  "Главное учебное здание СПбПУ",
  "../assets/alternatives/main-building.jpg",
  width: 60%,
)<main-building>

Примером неудачной планировки является Научно-исследовательский корпус СПбПУ: он представляет собой сложную структуру с множеством коридоров и переходов, попасть в одну часть здания из другой можно только через лестничный пролёт, что вводит в заблуждение и затрудняет навигацию. Однако, оба здания обладают хорошей нумерацией кабинетов, что позволяет легко ориентироваться по этажам.

#fig(
  "Научно-исследовательский корпус СПбПУ",
  "../assets/alternatives/building-rnd.jpg",
  width: 60%,
)

Цветовое кодирование (color coding) — это метод, который позволяет выделить важные элементы с помощью разных цветов. Например, с помощью цвета можно выделить разные этажи или разные категории аудиторий, что позволит легче ориентироваться и проще запомнить расположение помещений @Alansari2022WayfindingIA. Похожее решение можно применить и на цифровых картах — например, выделять аннотации и типы кабинетов разными цветами.

#subfig(
  figure(image("../assets/alternatives/act-orange.jpeg"), caption: [Аудитории звукозаписи]),
  figure(image("../assets/alternatives/act-purple.jpeg"), caption: [Компьютерные классы]),
  columns: (1fr, 1fr),
  caption: [Цветовое кодирование в дизайне интерьеров],
)

=== Цифровой подход корпораций

Цифровой подход корпораций заключается в разработке карт масштаба городов и стран, ориентированных на массовое потребление. Многие из них включают функционал планировки помещений, однако компании не дают возможности размещать на своих картах произвольные планировки и выставляют жёсткие требования к тем помещениям, которые они размещают самостоятельно. Здания должны быть публичными и часто посещаемыми. В основном, под такие требования подходят аэропорты, вокзалы и крупные торговые центры. Размещение планировок университетов или конференц-залов, которые используются ограниченным кругом лиц, корпорациям невыгодно.

Подробный анализ существующих картографических приложений от корпораций был рассмотрен в бакалаврской работе, в рамках которой была реализована пилотная версия PolyMap. Рассмотрим изменения в этой области с тех пор.

==== Apple Maps
Apple Maps — это картографический сервис от компании Apple, представленный на iOS и MacOS. В настоящее время является наиболее качественным картографическим сервисом в техническом плане.

#par(first-line-indent: 0pt)[Преимущества:]
- Высокая детализация улиц
- Дороги реальной ширины с разметкой
- Поддержка 3D и 2D проекций
- Поддержка планировок помещений, в том числе в 3D

#par(first-line-indent: 0pt)[Недостатки:]
- Только для iOS и MacOS
- Нет возможности размещать свои карты
- Маршруты внутри помещений не строятся

В июле 2024 года стала доступна веб-версия Apple Maps в режиме беты с серьёзными ограничениями, с тех пор обновлений не было, и в настоящее время карты доступны в бета-версии. Планировок помещений нет. Реальной ширины дорог и разметки нет.

#subfig(
  figure(image("../assets/alternatives/apple.jpeg"), caption: [Карты территорий]),
  figure(image("../assets/alternatives/apple-indoor.jpg"), caption: [Карты помещений]),
  columns: (1fr, 1fr),
  caption: [Пример Apple Maps],
)

==== Google Maps

За последние годы Google Maps было выпущено несколько крупных обновлений, одно из которых — поддержка дорог реальной ширины, а также разметки на дорогах, как и в Apple Maps.

#par(first-line-indent: 0pt)[Преимущества:]
- Дороги реальной ширины с разметкой
- Поддержка 3D
- Поддержка планировок помещений, только в 2D
- Доступна на всех платформах, в том числе и в вебе

#par(first-line-indent: 0pt)[Недостатки:]
- В 2D-режиме, вместо ортографической проекции используется вид сверху на 3D, что неудобно, так как создаёт перспективные искажения, особенно вокруг высоких зданий (небоскрёбов). В настройках карт можно в принципе отключить объёмные здания, и это решает проблему, однако отключает их и в 3D-режиме тоже.
- Нет возможности размещать свои карты
- Маршруты внутри помещений не строятся
- Плохая детализация пешеходной среды

#subfig(
  figure(image("../assets/alternatives/google.jpg"), caption: [Карты территорий]),
  figure(image("../assets/alternatives/google-indoor.jpg"), caption: [Карты помещений]),
  columns: (1fr, 1fr),
  caption: [Пример Google Maps],
)

==== Яндекс Карты

Наиболее детализированные карты в России, за последние годы было несколько обновлений, однако сильно ухудшилась стабильность работы сервиса.

#par(first-line-indent: 0pt)[Преимущества:]
- Высокая детализация в России
- Дороги реальной ширины с разметкой, но только в режиме навигатора (@yandex-nav)
- Поддержка 3D
- Поддержка планировок помещений, только в 2D
- Доступна на всех платформах, в том числе и в вебе

#par(first-line-indent: 0pt)[Недостатки:]
- Вместо 2D-проекции используется вид сверху на 3D, аналогично Google Maps
- Многоуровневые автомобильные развязки сделаны в 2D (накладываются друг на друга с имитацией тени)
- Нет возможности размещать свои карты
- Маршруты внутри помещений не строятся (было анонсировано, но не работает)
- Реальная ширина дорог доступна только в режиме автомобильного навигатора

#subfig(
  figure(image("../assets/alternatives/yandex.jpeg"), caption: [Карты территорий]),
  figure(image("../assets/alternatives/yandex-indoor.jpg"), caption: [Карты помещений]),
  columns: (1fr, 1fr),
  caption: [Пример Яндекс Карт],
)

#fig("Пример Яндекс Карт в режиме навигатора", "../assets/alternatives/yandex-nav.jpg", width: 50%)<yandex-nav>

В декабре 2022 года Яндекс анонсировал новое поколение Яндекс Карт с высокой детализацией, в полноценном 3D-режиме и хорошо развитой пешеходной средой. Однако в настоящий момент (май 2025 года) новое поколение карт так и не появилось, никаких новостей больше не было. Часть функционала, такая как разметка на дорогах, была добавлена в старую версию карт.
#fig("Новое поколение Яндекс Карт", "../assets/alternatives/new-yandex.jpg", width: 100%)

=== Цифровой подход стартапов

В отличие от крупных корпораций, стартапы намного более гибкие и клиентоориентированные. Существует множество картографических сервисов, созданных небольшими компаниями для решения узкого спектра задач. Рассмотрим те из них, которые ориентированы на планировку помещений и прилегающей территории.

Значимой проблемой практически всех карт является низкое качество самих карт: они медленно работают, зависают, сделаны поверх картографических библиотек, которые сильно ограничивают возможность наложения. Кроме того, многие фокусируются только на планировках одного здания и не поддерживают навигацию по территории. У многих компаний рекламируемый результат не соответствует действительности, а найти реальный пример их карт достаточно сложно.

==== MazeMap
MazeMap работает в формате SAAS (Software as a Service) @SaaS, то есть предоставляет готовое решение для размещения карт.

#par(first-line-indent: 0pt)[Преимущества:]
- Надёжная компания с хорошей репутацией
- Реальные примеры карт общедоступны
- Поддержка нескольких зданий на территории
- Поддержка маршрутов внутри помещений
- Поддержка сквозных маршрутов по территории

#par(first-line-indent: 0pt)[Недостатки:]
- Устаревший дизайн
- Нет веб-версии
- Непрозрачная ценовая политика
- Просмотр карт реализован в виде слоя наложения поверх библиотеки MapBox
- Планировка территорий используется от OpenStreetMap, нельзя указать свою
- Нет поддержки 3D

#subfig(
  figure(image("../assets/alternatives/mazemap.jpg"), caption: [Карты территорий]),
  figure(image("../assets/alternatives/mazemap-indoor.jpg"), caption: [Карты помещений]),
  columns: (1fr, 1fr),
  caption: [Пример MazeMap],
)


==== Mappedin
Mappedin работает в формате SAAS, прозрачное ценообразование, открытый конструктор карт. Промо-ролик на главной странице сайта выглядит красиво, но не соответствует действительности. Реальные примеры карт общедоступны. Если сервис сможет реализовать карты так, как показано в концептуальном видео, это будет самый качественный сервис на рынке.

#subfig(
  figure(image("../assets/alternatives/mappdin-concept.jpg"), caption: [Обещание на сайте]),
  figure(image("../assets/alternatives/mappedin.jpg"), caption: [Реальная карта]),
  columns: (1fr, 0.56fr),
  caption: [Пример Mappedin],
)

#par(first-line-indent: 0pt)[Преимущества:]
- Наличие веб-версии
- Открытый и бесплатный конструктор карт
- Прозрачное ценообразование
- Красивый рекламный ролик (не соответствует действительности)
- Частичная поддержка 3D
- Поддержка ИИ для автоматической генерации карт
- Поддержка маршрутов внутри помещений
- Поддержка мобильной версии

#par(first-line-indent: 0pt)[Недостатки:]
- Конструктор карт работает плохо, часто зависает
- Мало примитивов для создания карт (стены, двери, окна). Нет лестниц, нет возможности разметить помещения по категориям
- Устаревший дизайн
- Ограниченная возможность разместить несколько зданий на одной карте
- Нет возможности определить свою планировку территории

==== Concept3D
Concept3D — компания предоставляет художественные карты, которые выглядят красиво, однако являются 2D статичными изображениями.

#par(first-line-indent: 0pt)[Преимущества:]
- Красивый художественный стиль карт
- Наличие веб-версии
- Поддержка маршрутов внутри помещений
- Поддержка сквозных маршрутов по территории
- Поддержка своих планировок территории

#par(first-line-indent: 0pt)[Недостатки:]
- Непрозрачная ценовая политика
- Обман ожиданий: карты выглядят объёмными, однако являются 2D иллюстрациями. При вращении карты эффект объёма пропадает из-за смены ракурса
- Плохая производительность
- Нет конструктора карт
- Плохая поддержка мобильной версии

#fig("Пример Concept3D", "../assets/alternatives/concept3d.jpeg", width: 50%)

== Сравнительная таблица существующих решений

В настоящее время существует множество картографических сервисов, однако все они имеют свои недостатки. У крупных корпораций хорошее качество приложений, но ограничена возможность размещать свои планировки; у стартапов, наоборот, есть возможность размещать свои карты, но качество приложений оставляет желать лучшего. Ниже представлена сравнительная таблица существующих решений с их возможностями.

#include "../assets/alternatives/compare-table.typ"

= Архитектура. Serverless подход

В этой главе рассмотрена верхнеуровневая архитектура сервиса PolyMap, выбран оптимальный подход к разработке серверной части, а также рассмотрен выбор оптимального облачного провайдера для реализации Serverless-архитектуры.

== Анализ требований и проектирование
Архитектура сервиса в первую очередь определяется требованиями и задачами, которые перед ней ставятся. Одним из подходов к постановке технического задания является использование пользовательских сценариев. Они позволяют описать требования к системе с точки зрения пользователя, что помогает лучше понять, как система будет использоваться в реальной жизни.

=== Ролевая модель. Сценарии использования

В сервисе PolyMap выделяются три основные роли:
- *Заказчик* — лицо, которое заказывает разработку карты.
- *Пользователь* — лицо, которое использует уже созданную карту.
- *Художник* — лицо, которое по поручению заказчика оцифровывает карту в конструкторе сервиса.

При этом заказчик и художник могут быть одним и тем же лицом, так как в большинстве случаев заказчик сам будет оцифровывать карту. Однако в некоторых случаях заказчик может поручить эту задачу художнику как своему представителю, так и заказать отрисовку карты у PolyMap.

#include "../assets/user-stories.typ"

Таким образом, верхнеуровневую архитектуру сервиса можно представить в виде трёх основных компонентов:
+ Клиентская часть — приложение, отображающее интерактивную карту.
+ Конструктор карт — доступен для заказчиков карт и художников, позволяет создавать и редактировать карты, а также загружать их на сервер.
+ Серверная часть — отвечает за хранение карт и сопутствующих данных, а также за обработку запросов от клиентской части.

Необходимо предусмотреть возможность расширения клиентской части до нативных мобильных приложений на iOS и Android, а также возможность в будущем предоставлять доступ к конструктору карт неограниченному числу лиц.

Также важным требованием является размещение серверной части в России, что позволит снизить инфраструктурные риски, связанные с политической ситуацией в мире.

#fig("Общая схема архитектуры приложения", "../assets/client-server-db.pdf", width: 90%)

== Клиентская часть
Для соответствия требованиям кроссплатформенности и скорости загрузки решено использовать веб-технологии для разработки клиентской части. Это позволяет использовать единое веб-приложение как на мобильных устройствах, так и на компьютерах. Кроме того, это позволяет избежать необходимости установки приложения на устройство, что значительно упрощает процесс использования сервиса и даёт пользователям более комфортный опыт (открыть сайт с картой быстрее и безопаснее для пользователя, чем скачивать и устанавливать приложение).

Клиентское веб-приложение всё ещё требует адаптации под разные устройства и способы пользовательского ввода. Для этого необходимо использовать адаптивный интерфейс, который будет подстраиваться под размер экрана устройства, а также поддерживать способы управления картой мышью и сенсорным экраном.

Клиентское приложение должно поддерживать следующие функции:
- Отображение карты в формате Extended-IMDF
  - Просмотр карты
  - Приближение и вращение карты
  - Просмотр планировок этажей
  - Переключение между этажами текущего здания
- Отображение аннотаций на карте и этажах
- Поиск по аннотациям на карте
- Просмотр информации об аннотации
  - Текстовое описание аннотации
  - Расположение аннотации на карте
- Построение маршрута по карте
  - Маршрут между двумя аннотациями
  - Маршрут от стандартной точки начала до аннотации (точка начала своя для каждой карты, их может быть несколько)
  - Маршрут должен бесшовно переходить от прилегающей территории к зданию и между этажами
- Должна быть возможность поделиться маршрутом с другими пользователями
  - С помощью постоянной URL-ссылки
  - С помощью QR-кода

Подробная реализация рассмотрена в #ref(<web-map-implementation>, supplement: "разделе").

== Конструктор карт
Конструктор карт является отдельным приложением, которое доступно для художников и заказчиков карт после авторизации. В нём можно создавать и редактировать карты, выгрузка их на сервер осуществляется из специального меню конструктора, которое будет доступно только для авторизованных пользователей. При планировании архитектуры сервиса необходимо предусмотреть будущее развитие конструктора до публичной веб-версии, к которой будет иметь доступ любой желающий. Общее видение проекта подразумевает бизнес-модель, аналогичную конструкторам сайтов, таким как Tilda@tilda или Wix@wix. То есть любой желающий сможет спроектировать карту, загрузить её на сервер и просмотреть, однако для того чтобы сделать её общедоступной, необходимо будет оплатить подписку.

Реализация веб-версии конструктора выходит за рамки текущей работы, однако планируется в дальнейших обновлениях сервиса, что накладывает ряд дополнительных требований к архитектуре:
- Весь процесс взаимодействия и обработки новых карт должен быть автоматизирован.
- Необходимо предусмотреть возможность добавления сервера синхронизации для совместной работы над одной картой.
- Необходимо заложить возможность масштабирования серверной части, отвечающей за обработку новых и изменения старых карт.

== Серверная часть
Сервис будет сталкиваться с неравномерной нагрузкой с ярко выраженными пиками, которые будут возникать в связи со следующими причинами:
- Повышенный спрос на карты университетов в начале учебного семестра
- Повышенный спрос на карты университетов в начале каждого дня. По утрам, в 10:00, 12:00 и 14:00, перед началом пар, студенты будут открывать карту, чтобы найти нужную аудиторию, что подтверждается статистикой использования пилотной версии (@appmetrika-day).
#fig("График использования PolyMap в течение дня", "../assets/appmetrika-day.png", width: 100%)<appmetrika-day>

- При использовании карты на временных конференциях и выставках большинство пользователей будут открывать карту одновременно, что создаст пиковую нагрузку на сервер.

Для решения этих проблем необходимо предусмотреть горизонтальное масштабирование серверной части. Для создания модульности кодовой базы, разделения ответственности и прав доступа, а так же с целью поддержки горизонтального масштабирования *был выбран микросервисный подход* к разработке.

== Serverless подход

Хотя Kubernetes остаётся наиболее популярным решением для оркестрации микросервисов @Vano2023CloudNativeWO @Schneider2020ACN, в последние годы набирает популярность альтернативный подход — Serverless. Он позволяет запускать и масштабировать микросервисы без необходимости взаимодействия с виртуальными или выделенными серверами @Tari2024AutoscalingMI. Вместо этого Serverless предлагает арендовать у облачных провайдеров только вычислительные ресурсы, которые фактически были использованы.

К основным недостаткам Kubernetes относят сложность настройки качественной инфраструктуры, высокий риск ошибок при ручной настройке, сложность управления версиями, а также высокую стоимость кластера, особенно на начальных этапах разработки и тестовых средах.

=== Преимущества и недостатки
Как и любой другой подход, Serverless имеет свои плюсы и минусы. Преимущества Serverless вытекают из недостатков Kubernetes:
+ Простота настройки и управления — при использовании Serverless разработчик не взаимодействует с виртуальными серверами, а только с облачными ресурсами, которые предоставляют достаточно простой и однозначный интерфейс управления.
+ Низкая вероятность ошибок — поскольку разработчик не взаимодействует с виртуальными серверами, вероятность ошибок при настройке инфраструктуры значительно снижается. Кроме того, облачные провайдеры предоставляют такие настройки, которые не позволяют допустить существенную ошибку.
+ Низкая стоимость — Serverless распространяется по модели pay-as-you-go, то есть необходимо оплачивать только те ресурсы, которые были фактически использованы, что хорошо видно на #ref(<serverless-vs-dedicated>, supplement: "рисунке"). Это позволяет значительно снизить затраты на инфраструктуру @soprachevServerless.

#fig(
  "Сравнение затрат на инфраструктуру",
  "../assets/serverless-vs-dedicated.pdf",
  width: 90%,
)<serverless-vs-dedicated>

За счёт того, что микросервисы в Serverless-подходе запускаются только во время запроса пользователя и отключаются после завершения обработки, они потребляют ресурсы облака только в момент фактической работы, в отличие от Kubernetes, где необходимо арендовать виртуальные серверы вне зависимости от их использования. При переменной нагрузке Kubernetes будет простаивать значительное время, что приведёт к нерациональным затратам, которых позволяет избежать Serverless.

Однако у Serverless есть и свои недостатки:
+ Требования к чистой архитектуре — Serverless-подход требует от разработчиков строгого соблюдения принципов чистой архитектуры:
  - микросервисы должны быть независимыми друг от друга
  - связи должны быть реализованы через очереди сообщений
  - микросервисы должны быть Stateless — то есть не должно храниться внутреннее состояние, оно будет потеряно при перезапуске микросервиса
+ Привязанность к облачному провайдеру — Serverless реализован у большинства крупных облачных провайдеров, однако конечная реализация может отличаться, что сильно усложняет миграцию между облачными провайдерами.
+ Ограниченность возможностей — не любую микросервисную архитектуру удастся реализовать с помощью Serverless. Например, большинство баз данных не поддерживают Serverless. Однако облака предоставляют доступ к Managed-версиям баз данных, к которым можно обращаться из Serverless-микросервисов. Кроме того, не все технологии смогут корректно работать в условиях короткого жизненного цикла.
+ Должно быть обеспечено быстрое время холодного старта — так как микросервисы запускаются только во время запроса, то время их запуска должно быть минимальным. Это накладывает ограничения на используемые технологии, подробнее о выборе подходящего технологического стека рассмотрено в #ref(<serverless-technology-stack>, supplement: "разделе").

=== Cloud-Native
В современном мире для разработки и развёртывания приложений всё чаще используется Cloud-Native-подход. Он подразумевает разработку приложений, которые будут работать в облаке, используя облачные ресурсы для хранения данных и вычислений. Это позволяет в некоторых аспектах упростить разработку и развёртывание приложений, а также значительно снизить затраты на поддержку и гарантии доступности @Oyeniran2024ACR.

Serverless является дочерним подходом к Cloud-Native-разработке. Именно этот подход был выбран для разработки серверной части приложения PolyMap.

=== Выбор облачного провайдера с применением СППР
Наиболее крупным игроком в сфере Serverless является Amazon Web Services (AWS), однако официально в России он недоступен, что создаёт дополнительные инфраструктурные риски. Поэтому в качестве облачного провайдера необходимо было выбрать отечественную альтернативу.
На текущий момент в России существует несколько крупных облачных провайдеров, предоставляющих Serverless-решения:
- Яндекс Облако — крупнейший в России облачный провайдер, который активно развивает как Serverless, так и Cloud-Native решения. Яндекс Облако предоставляет широкий спектр облачных услуг, включая Serverless Container, API Gateway, YDB, YQueue и другие.
- Selectel — старый игрок на российском рынке, в первую очередь ориентируется на выделенные серверы, однако Serverless-решения тоже присутствуют.
- Сбер Облако (переименовано в CloudRu) — относительно новый провайдер, активно развивается, имеет очень выгодные тарифы и бесплатные квоты.
- VK Cloud — ещё один новый провайдер, Serverless-решения не являются приоритетом.

Стоит отметить, что все эти провайдеры соответствуют требованиям российского законодательства о хранении данных (ФЗ-152), что является важным фактором при выборе облачного провайдера @Яхонтова2025СравнительныйАР.

Для выбора облачного провайдера было принято решение воспользоваться системой поддержки принятия решений (СППР)@soprachevSppr, которая позволяет сравнить облачные провайдеры по заданным критериям. В качестве критериев были выбраны следующие:
- Вычисления — функции (FaaS), наличие serverless-контейнеров, технические лимиты, квоты, удобство использования
- Интеграции — удобство вызовов функций/контейнеров (API Gateway), триггеры, очереди, CRON задачи
- БД, Очереди, Уведомления — управление данными, наличие serverless-решений, удобство работы, поддерживаемые протоколы
- DevOps & DX — наличие DevOps инструментов, документация, удобство автоматизации процессов. Оценивается CLI, SDK, наличие Terraform-провайдера, собственных GitHub/GitLab интеграций, активное сообщество (популярность)
- Мониторинг, логи — наличие инструментов мониторинга и логирования, удобство работы с ними, внутренний функционал (создание своих графиков, алертов, язык запросов и т.д.), а также интеграция с внешними системами.

Кроме отечественных облачных провайдеров, в таблице представлены и зарубежные @George2024ComparingSS:
- AWS — на текущий момент является лидером в области Serverless, однако официально недоступен в России.
- Google Cloud Platform — второй по популярности облачный провайдер, который активно развивает Serverless-решения.
- Azure — облачный провайдер от Microsoft, в нём тоже присутствует Serverless, однако акцент на нём не делается.

Для всех критериев были проставлены оценки по шкале от 0 до 10:
\ 0–3 — функционал полностью отсутствует либо пользоваться крайне неудобно.
\ 4–5 — функционал присутствует, но выполняет базовый минимум задач, серьёзно уступает альтернативам.
\ 6–7 — работает, но есть заметные пробелы, требует ручной настройки.
\ 8–9 — работает хорошо, покрывает все задачи, работать удобно, но есть небольшие недочёты.
\ 10 — самый полный и удобный на рынке функционал в данной категории.

С использованием 5 алгоритмов был рассчитан общий балл для каждого облачного провайдера. В @sppr-cloud-report находится подробный отчёт СППР. Использовалась собственная реализация СППР с открытым исходным кодом.

#figure(caption: [Результат работы СППР])[
  #show table.cell.where(y: 0): set text(weight: "bold")
  #table(
    columns: (auto, auto, auto, auto, auto, auto, auto, auto),
    align: horizon,
    table.header([Вариант], [Дом], [Блок], [Тур], [Sjp], [Sjm], [ИТОГО], [Место]),
    [*Yandex*], [5], [6], [5], [5], [6], [27], [3],
    [*Selectel*], [5], [6], [2], [2], [6], [21], [6],
    [*VK*], [5], [6], [1], [1], [6], [19], [7],
    [*Sber*], [5], [6], [3], [3], [6], [23], [5],
    [*AWS*], [7], [7], [7], [7], [7], [35], [1],
    [*Google*], [6], [6], [6], [6], [6], [30], [2],
    [*Azure*], [5], [6], [4], [4], [6], [25], [4],
  )
]<sppr-cloud-provider-result>

Как видно из таблицы #ref(<sppr-cloud-provider-result>, supplement: none), наибольшим требуемым функционалом обладает AWS, однако он, как и Google и Azure, недоступны в России. Наивысший балл среди отечественных сервисов получило Yandex Cloud, поэтому оно было выбрано в качестве облачного провайдера для проекта. Sber Cloud активно развивает свои Serverless-решения, однако на момент написания работы всё ещё сильно отставал от Yandex Cloud. Selectel и VK имеют очень урезанный Serverless-функционал, который не позволяет реализовать проект в полном объёме.

=== Обзор Serverless компонентов Яндекс Облака
Подход к Serverless в Yandex Cloud @YC реализован с помощью следующих компонентов:
- Cloud Functions — позволяет запускать код в ответ на события, такие как HTTP-запросы или CRON задачи.
- Serverless Container — позволяет запускать Docker @docker контейнеры в ответ на различные события.
- API Gateway — позволяет описывать REST API для микросервисов в формате OpenAPI. Является публичной точкой входа в микросервисы.
- Message Queue — позволяет организовать асинхронную связь между микросервисами. Совместим с Amazon SQS API.
- Yandex Data Base (YDB) — Serverless-база данных, которая может работать и в реляционном, и в документо-ориентированном режимах. Совместима с DynamoDB API.
- Object Storage — объектное хранилище, которое позволяет хранить и раздавать бинарные объекты по протоколу S3.
- Cloud Postbox — сервис, который позволяет организовывать Email-рассылки. Совместим с Amazon SES API.

В проекте не используются Cloud Functions, так как все микросервисы реализованы в виде Docker-контейнеров — это позволяет использовать более привычный подход к разработке и тестированию, а также уменьшает привязанность к облачному провайдеру. Архитектура, состоящая полностью из контейнеров, может быть легко перенесена как на локальную машину, так и в другие облака. Кроме того, использование контейнеров позволяет применять больший набор технологий, в том числе и те, которые не поддерживаются в Cloud Functions.

Кроме непосредственно Serverless-компонентов Yandex Cloud предоставляет и другие сервисы, которые будут полезны в проекте:
- Container Registry — позволяет хранить Docker-образы, которые будут использоваться в Serverless Container.
- Monitoring — позволяет хранить и отслеживать состояние работы проекта: число запросов, время ответа и другие метрики. Кроме того, позволяет настраивать Alerting, который будет уведомлять о проблемах в работе проекта при срабатывании настроенных условий.
- Cloud Logging — позволяет собирать, хранить, фильтровать и просматривать логи из всех микросервисов в одном месте.

Yandex Cloud активно развивает Serverless-раздел облака и регулярно добавляет новые компоненты и улучшения. Например, на момент написания магистерской работы в облако был добавлен Notification Service, который позволяет отправлять персональные уведомления пользователям через SMS, Push и Email. Это позволит в будущем расширить функционал сервиса PolyMap, сильно упростив реализацию личного кабинета заказчика.

=== Content Delivery Network (CDN)
Для решения задачи быстрого отклика из разных регионов, необходимо использовать Content Delivery Network (CDN) сети. Они пропускают запросы пользователей через географически ближайший к ним узел и, в случае если запрашиваемый ресурс разрешён для кеширования и уже есть в кеше, отдают его пользователю, не перенаправляя запрос на основной сервер. Главным источником трафика в сервисе является раздача карт — это большие и тяжёлые файлы, которые будет скачивать каждый пользователь при каждом открытии карты. Сами карты являются статическими файлами, которые редко меняются, а также в большинстве случаев привязаны к конкретной локации. Поэтому их можно эффективно кешировать в CDN-сети. Это позволит значительно снизить объём трафика и увеличить скорость открытия сайта, что положительно скажется на пользовательском опыте @Tyagi2025OptimizingDE @cdn-info.

#fig("Схема работы CDN", "../assets/sheme-cdn.svg", width: 100%)<cdn>

Общий принцип работы CDN состоит в передаче DNS-управления к CDN-провайдеру, после чего провайдер будет разрешать запросы к ближайшему узлу.

=== Жизненный цикл запроса
При использовании Serverless в Yandex Cloud жизненный цикл обработки запроса выглядит следующим образом:
+ Пользователь через DNS-сеть CDN определяет ближайший к нему узел и отправляет запрос на него.
+ Узел CDN проверяет, есть ли запрашиваемый ресурс в кеше. Если он есть, то отдаёт его пользователю, если нет — проксирует запрос в Yandex Cloud.
+ Yandex Cloud получает запрос и по домену находит соответствующий `API Gateway`, который будет обрабатывать запрос.
+ `API Gateway` проводит часть проверок (авторизацию, валидацию параметров) и перенаправляет запрос на соответствующий `Serverless Container`, который будет обрабатывать запрос.
+ Если нет запущенного экземпляра `Serverless Container`, то Yandex Cloud создаёт новый экземпляр контейнера из локального `Docker Registry` и перенаправляет запрос на него.
+ `Serverless Container` обрабатывает запрос, при этом имеет возможность обращаться к прочим ресурсам Облака, таким как базы данных, очереди и т.д.
+ После обработки запроса `Serverless Container` возвращает ответ обратно в `API Gateway`, который в свою очередь возвращает его пользователю через CDN Proxy.
+ Если указаны заголовки кеширования, то CDN Proxy кеширует ответ на региональном узле и в дальнейшем будет отдавать его пользователям, не перенаправляя запрос на основной сервер.

В случае обновления статического контента есть возможность вызвать инвалидацию CDN-кеша с помощью специального API. Это позволит удалить из кеша старую карту, чтобы новая версия была доступна пользователям сразу после обновления.

#fig("Инфраструктурный путь запроса", "../assets/request-lifecycle.pdf", width: 100%)<request-lifecycle>

=== Ценообразование
Основным преимуществом Serverless-подхода является снижение инфраструктурных затрат относительно классических подходов. Рассмотрим ценообразование в Yandex Cloud.

Важным фактором затрат на Serverless в Yandex Cloud являются квоты на число бесплатно предоставляемых ресурсов. Эти квоты сбрасываются в начале каждого месяца, таким образом, низкая нагрузка в течение месяца позволяет пользоваться инфраструктурой полностью бесплатно. После исчерпания квот тарификация происходит по модели pay-as-you-go, то есть необходимо оплачивать только те ресурсы, которые были фактически использованы.

#include "../assets/serverless-price.typ"

=== Сравнение затрат на Serverless и Kubernetes

С использованием цен, актуальных на момент написания работы (@serverless-price), можно ориентировочно рассчитать общие затраты на инфраструктуру в месяц. Возьмём ориентировочную нагрузку на пилотную версию PolyMap iOS (@polymap-ios-usage).

#include "../assets/polymap-ios-usage.typ"

Стоит отметить, что приложение не имеет официального статуса, и его не использовали для приглашений на мероприятия. В связи с этим нагрузка на открытия приглашений сильно занижена, при реальном использовании на конференциях число открытий приглашений будет пропорционально пришедшим пользователям.

Перенесём статистику на примерный механизм работы Serverless:
- API Gateway: 600~000 открытий карт + 70~000 просмотров аннотаций + 10~000 построений маршрутов + 250 открытий приглашений = 680 250 запросов
- Serverless Containers: 680 250 вызовов (среднее потребление: 0.5~ГБ~RAM, 0.2~с процессора на вызов)
- Message Queue: 680 250 запросов
- Object Storage GET: 680~250 операций
- Исходящий трафик: #sym.approx 600 000 загрузок карт по #sym.approx 2 МБ = 1 200 ГБ

#include "../assets/serverless-polymap-cost.typ"

Как видно из расчёта (@polymap-serverless-cost), на самый нагруженный месяц — сентябрь, приблизительные затраты на Serverless-инфраструктуру составят *1600 рублей*, и большая часть затрат — это исходящий трафик, который порождается раздачей статичных файлов карты. Однако большинство этих запросов не будут доходить до серверов, а будут обрабатываться на узлах кеша CDN, поэтому реальные затраты будут значительно ниже.

Сравним это с затратами на Kubernetes-кластер. Так как нагрузка не очень высокая, возьмём минимальную production-конфигурацию кластера, которая будет состоять из 3 нод с 4 vCPU и 4 ГБ RAM. Три ноды позволят обеспечить доступность и отказоустойчивость сервера, а 4 vCPU и 4 ГБ RAM будет достаточно для обработки аналогичной нагрузки. Такой кластер в Yandex Cloud будет стоить *33~000~рублей* в месяц, что значительно выше, чем затраты на Serverless. Для сравнения, на @selectel есть стоимость минимально возможного кластера в Selectel, он имеет меньшую отказоустойчивость, так как находится в одной зоне доступности, однако обладает большими характеристиками: 8~vCPU и 16~ГБ~RAM, такой кластер будет стоить *31~000~рублей* в месяц.

#subfig(
  figure(image("../assets/kubernetes-price-yandex.png"), caption: [Yandex Cloud]),
  figure(image("../assets/kubernetes-price-selectel.png"), caption: [Selectel]),
  <selectel>,
  columns: (1fr, 0.65fr),
  caption: [Стоимость Kubernetes кластера в Yandex Cloud и Selectel],
)

Также не стоит забывать, что кроме production-кластера необходимо будет поддерживать тестовый кластер для разработки и тестирования новых обновлений, что значительно увеличит затраты на инфраструктуру, в то время как в Serverless-подходе тестовые среды не будут выходить за пределы бесплатных квот. За три года активной разработки ни разу не использовалось более 10% от выделенных квот, что позволяет полностью бесплатно разрабатывать и тестировать обновления на реальной инфраструктуре.

== Поисковая оптимизация (SEO)
Важной частью любого веб-сервиса является поисковая оптимизация (SEO – Search Engine Optimization). Этим термином называют набор методов, которые позволяют улучшить видимость сайта в поисковых системах, таких как Google, Yandex и другие. Это позволяет увеличить количество пользователей, которые будут органически находить ресурс через поиск @LewandowskiSEO. В качестве методов SEO можно выделить:
- Оптимизация мета-тегов — это теги в заголовке HTML-страницы, которые содержат информацию о сайте: название, описание, ключевые слова, язык
- Создание OpenGraph мета-тегов — это специальный подвид мета-тегов, в которых описывается, как будет выглядеть предпросмотр ссылки на сайт в социальных сетях.
#todo[В идеале сюда добавить сравнительную картинку с OpenGraph тегами и без них]
- Персонализация страниц — для SPA (Single Page Application) приложений необходимо генерировать уникальные index.html страницы в зависимости от контента. Это можно сделать с помощью серверного рендеринга (SSR – Server Side Rendering) или статической генерации страниц (SSG).
- robots.txt — специальный файл, который позволяет указать поисковым системам, какие страницы сайта не нужно индексировать.
- Sitemap.xml — специальный файл, в котором описывается структура сайта, по которой поисковые системы могут понять, какие страницы сайта нужно индексировать, а какие — нет.

=== Применение SEO в PolyMap
В сервисе PolyMap есть два основных направления SEO:
+ Лендинг-страница с описанием возможностей сервиса, его преимуществами и примерами использования.
+ Веб-версия карт, которая отображает карты заказчиков.

В случае с лендинг-страницей особых сложностей в SEO нет, так как это статичный веб-сайт, который будет использовать SSG-подход, что позволит поисковым движкам с лёгкостью его анализировать.

Веб-версия карт куда сложнее — это SPA-приложение, которое в зависимости от URL будет подгружать карту уже после открытия сайта. При этом сами карты являются динамичным контентом, они могут добавляться новые, а старые исчезать.
SPA-приложения работают следующим образом: с сервера загружается пустой index.html файл, в котором объявлен основной JavaScript-файл, после скачивания которого приложение запустит фреймворк и динамически нарисует страницу.

Для поисковой оптимизации SPA с динамическим контентом принято использовать SSR-подход. При нём, на каждый запрос пользователя, на сервере запускается JavaScript-код приложения и создаёт полную HTML-страницу, после чего прикрепляет состояние фреймворка в виде JSON-объекта и отвечает пользователю. На стороне пользователя запускается процесс гидратации (hydration) — это процесс, при котором фреймворк берёт HTML-страницу и JSON-объект, и запускает приложение с уже готовым состоянием. Однако этот подход значительно увеличивает нагрузку на сервер, увеличивает скорость ответа, а также время до первого взаимодействия (Time to First Interaction — TTFI), что происходит из-за медленного процесса гидратации.

Для PolyMap был выбран другой подход. Благодаря тому, что карты не являются текстовым контентом, можно использовать SSG только для мета-тегов, а всё остальное генерировать на стороне клиента классическим SPA-подходом.
Для генерации мета-тегов достаточно подменить их в index.html файле, получаемом от фреймворка; никакие другие скрипты в процессе участвовать не будут. В проекте для этого используется отдельный микросервис `web-map-back`, который в зависимости от URL будет генерировать нужную index.html страницу, а также по запросу поисковых движков будет генерировать актуальные sitemap.xml и robots.txt файлы. Подробнее о его работе будет рассказано в разделе #ref(<web-map-back>, supplement: none).

== Детальная архитектура

Детальная архитектурная схема сервиса PolyMap представлена на рисунке #ref(<detailed-architecture>, supplement: none). Её можно разделить на несколько основных типов компонентов:
- Клиенты — это приложения, с которыми взаимодействует пользователь, заказчик и художник. Они могут быть как веб-приложениями, так и нативными программами. На схеме они представлены блоками фиолетового цвета.
- Внешние сервисы — не являются частью PolyMap, однако взаимодействуют с сервисом. Например, внешние сервисы аналитики или запросы OpenGraph Meta. На схеме они представлены блоками тёмно-серого цвета.
- Микросервисы — это основные вычислительные компоненты. На схеме они представлены блоками белого цвета.
- CDN — это прослойка между клиентами и микросервисами, которая позволяет кешировать статические файлы. На схеме она представлена блоками оранжевого цвета.
- Системы хранения — это места хранения данных, на схеме представлены:
  - Синим цветом, префикс *`SQL`* — SQL-базы данных, например PostgreSQL или YDB в SQL-режиме.
  - Зелёным цветом, префикс *`DOC`* — документо-ориентированные базы данных, например YDB в NoSQL-режиме или MongoDB.
  - Оранжевым цветом, префикс *`S3`* — объектные хранилища S3.
  - Синим цветом, префикс *`OLAP`* — аналитические базы данных, например ClickHouse.

#fig(
  "Детальная схема архитектуры PolyMap",
  "../assets/polymap-detailed-architecture.pdf",
  width: 100%,
)<detailed-architecture>

Далее компоненты архитектуры будут рассмотрены подробнее, будет определено их назначение и обоснована значимость для сервиса.

=== Клиенты
Клиентами являются приложения, с которыми взаимодействует пользователь, такие приложения подразумевают графический пользовательский интерфейс. При проектировании архитектуры сервиса PolyMap необходимо учитывать следующие клиенты:
- Dashboard — панель управления для заказчиков.
- Constructor — приложение для художников, которое позволяет создавать карты.
- iOS App, Android App, Web Map — приложения, которые позволяют просматривать карты.
- Landing — сайт с описанием сервиса, его возможностей и преимуществ.

==== Dashboard
Архитектурный компонент, запланированный на будущее. Это веб-приложение с панелью управления, доступ к которому будет выдаваться каждому заказчику. В нём будет доступен список карт, которые были созданы этим заказчиком. Будет возможность оплаты и подробная информация о каждой карте.

Для каждой карты можно будет просматривать аналитику (подробнее @analytics), настраивать доступ к карте, управлять художниками, переходить к конструктору карты, настраивать внешние интеграции (такие как расписание), просматривать список приглашений и их статистику.

Данный компонент не является критическим для работы сервиса, и его реализация не является приоритетной задачей. Он будет реализован в будущем, когда платформа будет готова к коммерческому использованию.

==== Constructor
Это компьютерное приложение, которое позволяет создавать карты. В будущем оно будет перенесено в веб-приложение с системой разграничения доступа. В текущий момент используется старая версия конструктора, разработанная в рамках бакалаврской ВКР. Оно написано на базе движка Unity3D с добавлением специальных окон.

==== iOS App, Android App, Web Map
Клиентские приложения, непосредственно отображающие карты. В рамках текущей работы реализуется только веб-версия приложения, однако планирование архитектуры требует учёта всех версий, которые будут реализованы в будущем.

==== Landing
Это веб-сайт, на котором будет размещена общая информация о сервисе, его преимуществах, возможностях и ценах. На сайте можно будет оставить заявку на создание карты. Сайт реализован в виде статического сайта, который будет раздаваться через CDN. Серверной части не требует, с другими микросервисами не взаимодействует.

=== Микросервисы<microservices>
Микросервисами являются приложения, с которыми взаимодействуют клиенты (приложения) или другие микросервисы. Такие приложения не подразумевают графический интерфейс, взаимодействие с ними происходит через API.

==== Dashboard-back
Этот микросервис будет реализован в будущем вместе с панелью управления (Dashboard). Он будет отвечать за взаимодействие с панелью управления, регистрацию заказчиков, хранение сервисных настроек карт, управление картами, расчёт аналитических графиков.

Также через него можно будет задать OpenGraph метаданные для карт. Он будет взаимодействовать с другими микросервисами: `map-storage`, `analytics`.

==== Constructor-WS
Это микросервис, который будет отвечать за синхронизацию совместной работы в конструкторе карты. Он будет использовать pub/sub WebSocket, клиенты конструктора будут отправлять delta-синхронизации.
На схеме архитектуры (@detailed-architecture) этот компонент помечен тегом `VPS`, что означает, что он не является частью Serverless. Это связано с тем, что на момент написания работы в Yandex Cloud тарификация WebSocket-соединений оплачивается за каждое сообщение, по цене эквивалентной обычным запросам, что делает это невыгодным. При этом данный сервер синхронизации не требует большой вычислительной мощности и гибкого масштабирования, так как будет доступен для малой группы художников в момент редактирования карт. Поломка механизма синхронизации не приведёт к критичным последствиям. Поэтому он будет реализован в виде обычного виртуального сервера, на котором будет запущен сервер Nginx и Docker-контейнер с сервисом синхронизации.

==== Blob-storage
Микросервис хранения бинарных объектов. Он может использоваться разными сервисами, но в первую очередь предназначен для конструктора карт, чтобы художники могли загружать свои собственные изображения аннотаций, планы этажей и т.д. Непосредственно хранение будет осуществляться в объектном хранилище S3, а сервис будет отвечать за управление доступом @TsenosDynamicStorage. Некоторые ассеты конструктора должны быть приватными и доступны только внутри конструктора и только для определённой карты (например, инженерные планировки), а некоторые должны быть публичными, такие как изображения аннотаций.

Загружать новые ассеты в хранилище смогут только художники, уровень доступа ассетов будет определяться картой, из которой они были загружены.

==== Constructor-back
Микросервис, обслуживающий конструктор карт. Он будет отвечать за сохранение карт из конструктора, а также за дополнительную обработку карты и её экспорт в `map-storage`. Будет предоставлять все ассеты карты в редактируемом виде (для конструктора) с учётом авторизации художника.

==== Map-storage
Самый важный микросервис для проекта, отвечает за хранение и раздачу карт. Кроме самих файлов карт для клиентов, он будет позволять получать информацию об аннотации, не скачивая всю карту целиком. Будет хранить метаданные карты и OpenGraph метаданные, в том числе картинки. Этот же микросервис будет отвечать за инвалидацию кеша CDN при обновлениях карт.

Получать информацию об аннотациях нужно будет из микросервиса `web-map-back` для генерации OpenGraph метаданных для SEO-оптимизации страниц аннотаций. Например, при открытии страницы `/spbstu/annotation/uuid` будут получаться информация об аннотации с `uuid` для карты `spbstu` и генерироваться OpenGraph метаданные для страницы конкретной аннотации. Это позволит поисковым движкам лучше индексировать страницы популярных аннотаций и выдавать их в результатах поиска.

==== Share-back
Вспомогательный микросервис для клиентов, который отвечает за создание приглашений на карту. Приглашения состоят из аннотации на карте или маршрута, а также названия с описанием. Необходимо сохранить эту информацию в базе данных и вернуть пользователю уникальный короткий URL. По реализации этот сервис очень схож с классической задачей сокращения ссылок. Ничего специфичного в нём нет.

==== Qr-generator
Один из самых дискуссионных микросервисов. Он отвечает за генерацию QR-кодов, которые нужны клиентам для создания приглашений. Эти QR-коды должны быть стилизованными, должны поддаваться настройке по цветам и виду, а также предоставляться в виде растровой `png` картинки или векторного `svg` изображения.

Может показаться, что его реализация в виде микросервиса нецелесообразна, и куда эффективнее было бы использовать клиентскую библиотеку, которая бы генерировала QR-коды прямо на клиенте без необходимости использования сервера. Однако в дальнейшем платформу планируется развивать до нативных мобильных приложений на других языках программирования, а стилизация QR-кодов везде должна быть одинаковой. Кроссплатформенных библиотек для стилизации QR-кодов, соответствующих требованиям, не существует, и пришлось бы разрабатывать её самостоятельно. Кроме того, в случае с мобильными приложениями, обновление этой библиотеки потребовало бы обновления приложения, а далеко не все пользователи обновляют их своевременно. Ещё одним аргументом в пользу микросервиса является то, что генерация QR-кода может быть востребована другим сервером, например, для Email-рассылок, в случае с которыми пришлось бы не просто использовать библиотеку на сервере, а ещё и сохранять изображения QR-кодов в S3.

В случае с использованием микросервиса все сложности по стилизации QR-кодов нивелируются. Сервис предоставляет REST API, в котором все настройки стилистики QR-кода определяются в виде `query` параметров, а в результате возвращается изображение. Этот подход позволяет:
- Использовать один и тот же сервис для всех платформ
- Для вложений использовать просто URL-ссылку на QR-код, который будет генерироваться в момент запроса (что полезно для Email-рассылок)
- Не зависеть от обновлений библиотек, так как сервис будет поддерживаться отдельно от клиентских приложений
- Не сохранять QR-коды в S3, а генерировать их в момент запроса, что позволяет избежать лишних затрат на хранение.
- Кешировать QR-коды на CDN, что позволит избежать лишних запросов (например, для рассылок)

#todo[В идеале сюда добавить пример URL для генерации QR-кода и сам QR-код]

==== Analytics<analytics>
Сервис для сбора аналитики от клиентов. Будет собирать информацию о событиях на картах и анонимизированную информацию о пользователях. Это нужно для того, чтобы заказчики карт могли видеть, как пользователи взаимодействуют с картами, какие аннотации открываются чаще всего, какие маршруты строятся, как часто пользователи открывают карту, сколько их, оценивать удержание. Сервис будет сохранять информацию в ClickHouse — это колоночная СУБД, предназначенная специально для аналитики. Собственное хранилище аналитики позволяет избежать использования сторонних сервисов, таких как Google Analytics, которые могут собирать информацию о пользователях и передавать её третьим лицам. Это важно для соблюдения GDPR, ФЗ-152 и других законов о защите персональных данных. Кроме того, собственное хранение позволит бесплатно и в любых количествах фильтровать аналитику по карте и выдавать эту информацию заказчикам. Сторонние сервисы ограничивают запросы к API, особенно с дополнительными фильтрами, так как их базы данных не предназначены для этого.

==== Web-map-back<web-map-back>
Этот микросервис крайне важен для SEO-оптимизации карты, веб-версия которой является Single Page Application (SPA), что усложняет классические методики SEO @Kowalczyk2024EnhancingSI. Он занимается генерацией index.html страницы для web-версии карт. В зависимости от URL запроса он будет добавлять в сгенерированный UI фреймворком index.html файл мета-теги, которые будут использоваться поисковыми движками для индексации страницы, а также обслуживать нужды поисковых движков, возвращая корректные:
- `sitemap.xml` — структура сайта, в ней будут URL всех карт, которые отмечены как публичные. Эти карты будут индексироваться поисковыми движками. Например, на запрос "Карта Политеха" в поисковой системе будет отображаться сайт PolyMap с соответствующей картой. В будущем можно будет попробовать добавить ещё и все аннотации на каждой карте, чтобы прямо в поисковике можно было искать "Политех корпус 1, аудитория 101" и получать ссылку на карту с соответствующей аннотацией.
- `robots.txt` — служебный файл, который позволяет указать поисковым системам, какие страницы сайта не нужно индексировать; будет использоваться для приватных карт, которые не должны индексироваться поисковыми системами.
- `.well-known/apple-app-site-association` — специальный файл, который позволяет iOS-устройствам открывать ссылки на карты в нативном приложении, а не в браузере.

==== Og-generator
Микросервис по функционалу аналогичный `qr-generator`, но генерирует не стилизацию QR-кодов, а OpenGraph-изображения, которые будут использоваться социальными сетями для предпросмотра ссылок на карты. Микросервис `web-map-back` будет создавать мета-теги, в том числе по протоколу OpenGraph, помещая в `og:image` специальные URL на микросервис `og-generator`, который по GET-запросу на этот URL будет генерировать изображение. Изображение кешируется в CDN. Все параметры изображения определяются в `query` параметрах ссылки. Будет поддерживаться генерация названия карты, аннотации, возможно предпросмотра маршрута. Кроме того, заказчики смогут кастомизировать свои OpenGraph-изображения, например добавлять логотипы, в этом случае `web-map-back` будет добавлять ссылку на эти изображения в `S3:OGImg`. Это позволит сделать `og-generator` полностью изолированным от других микросервисов, что считается хорошей архитектурной практикой.
#todo[В идеале сюда добавить картинку OpenGraph]

== Вывод
В данной главе были проанализированы требования к сервису, определён Serverless-подход к архитектуре, с помощью системы поддержки принятия решений выбран оптимальный облачный провайдер Yandex Cloud. Также была подробно рассмотрена детальная архитектура, разбивка на клиентов и микросервисы, обоснована их целесообразность и взаимодействие. Рассмотрена оптимизация поисковых запросов.

В результате получилась хорошая чистая архитектура, в которой все компоненты слабо связаны между собой.

= Реализация
В этой главе будут рассмотрены некоторые детали реализации сервиса PolyMap, такие как система контроля версий, непрерывная интеграция и развёртывание (CI/CD), а также некоторые детали реализации отдельных микросервисов. Будут выбраны языки программирования, фреймворки и основные библиотеки, которые будут составлять технический стек проекта. Также будет рассмотрена система мониторинга и логирования, которая будет использоваться в проекте.

== Система контроля версий
При разработке проекта в микросервисном подходе выделяют два способа организации системы контроля версий:
+ Монорепозиторий — все микросервисы хранятся в одном репозитории. Плюсом этого подхода является сквозное версионирование всех микросервисов: каждый коммит порождает новую общую версию приложения, которая гарантированно не нарушит совместимость. Минусом такого подхода является сильная связанность между микросервисами, что усложняет их независимую разработку, тестирование и развёртывание.
+ Полирепозиторий — каждый микросервис хранится в своём репозитории. Плюсом такого подхода является независимость разработки, тестирования и развёртывания каждого микросервиса. Минусом такого подхода является сложность в управлении версиями. Может случиться так, что при обновлении одного микросервиса сломается совместимость с другим.

Выбран второй подход, так как он лучше позволяет разделить кодовые базы и вести независимую разработку @Shakikhanli2022ComparisonBM. Сложность версионирования решается гарантиями обратной совместимости — ни одна новая версия не должна ломать совместимость с предыдущими версиями. Это требование и так необходимо соблюдать, чтобы корректно работало горизонтальное масштабирование, при котором в один момент времени могут работать несколько версий одного микросервиса.

=== Выбор системы контроля версий

В качестве системы контроля версий можно использовать несколько сервисов на базе Git @git:
- GitHub @github -- наиболее популярный коммерчиский сервис от компании Microsoft. Имеет огромное количество готовых интеграций и плагинов. Активно развивается и внедряет искусственный интеллект в разработку.
- GitLab @gitlab -- сервис с открытым исходным кодом, который можно установить на собственные сервера. Имеет встроенные CI/CD инструменты и интеграции с облачными провайдерами.
- Bitbucket @bitbucket -- сервис от компании Atlassian, который также имеет встроенные CI/CD инструменты. Однако он менее популярен и имеет меньшее количество интеграций, чем GitHub и GitLab.

Каждая из них обладает своими плюсами и минусами. Для выбора была составлена сравнительная таблица функционала, который потребуется для разработки проекта.

#include "../assets/git-services-compare.typ"

Как видно из таблицы #ref(<git-provider-comparison>, supplement: none), GitHub и GitLab имеют весь необходимый функционал и не уступают друг другу, Bitbucket сильно отстаёт от конкурентов. GitLab имеет важное преимущество — возможность размещать сервис полностью на своей инфраструктуре (self-hosted), что полезно для крупных компаний с корпоративными секретами, однако не имеет особого смысла в небольших проектах. В свою очередь, облачная версия GitHub является более удобной, намного популярнее любых конкурентов, CI/CD процессы обладают огромным количеством готовых плагинов в GitHub Marketplace. Ещё одним важным направлением развития GitHub является интеграция нейросетей на всех этапах: GitHub Copilot добавляет подсказки кода в IDE, позволяет автоматически проверять и комментировать PullRequest'ы, а также в beta-режиме полностью самостоятельно писать код по поставленным задачам.

В GitHub была создана отдельная организация, в которой расположены все репозитории, связанные с проектом.
#fig("Организация Polymap в GitHub", "../assets/github-repo.jpg", width: 80%)<github-organization>

== Веб-карта <web-map-implementation>
Визитной карточкой всего сервиса является веб-карта: именно с ней будет взаимодействовать большинство пользователей и именно с неё будет начинаться знакомство новых заказчиков с сервисом. Поэтому крайне важно реализовать её максимально качественно. Основная задача веб-карты — это динамически отображать карты разных кампусов в формате Extended-IMDF (бал разработан в рамках бакалаврской ВКР), а также предоставлять пользователям возможность взаимодействовать с картами, строить маршруты, открывать аннотации, осуществлять поиск по аннотациям. Важной задачей является сделать поддержку не только компьютерной, но и мобильной версии с адаптированным интерфейсом и управлением.

=== Выбор основного фреймворка
Карта является одностраничным веб-приложением (SPA) и имеет много интерактивных элементов, что означает, что для её реализации необходимо использовать веб-фреймворк. Ввиду того, что карта будет активно обновляться и развиваться, к этому выбору стоит подойти с особой тщательностью. К основным фреймворкам, которые специализируются на разработке SPA, относятся:
- React — самый популярный фреймворк на текущий момент. Имеет огромное количество готовых библиотек, компонентов, плагинов и поддержку сообщества. Позиционируется как библиотека, что несколько снижает удобство разработки, однако это компенсируется сторонними расширениями. Разработан и поддерживается крупной мировой компанией.
- Vue — второй по популярности фреймворк, который активно развивается и является главным конкурентом React. С самого начала позиционируется как фреймворк, что позволило сделать более удобную работу с компонентами. Разрабатывается сообществом. Имеет много готовых библиотек и компонентов, однако их количество уступает React.
- Angular — устаревший фреймворк, который был одним из первых, но на текущий момент сильно уступает React и Vue. Создавать новые проекты на нём не рекомендуется.
- Svelte — новый фреймворк, который активно развивается и имеет много интересных идей. Популярность и количество библиотек сильно уступают React и Vue, большой акцент делается на производительность и простоту использования. Больше предназначен для небольших и быстрых сайтов, нежели для крупных веб-приложений.

На первый взгляд, очевидным выбором будет React, однако это не совсем так, и стоит углубиться в детали. Важным преимуществом Vue является система реактивности, и начиная с третьей версии был добавлен `composition api`, который вывел использование реактивности на новый уровень. С `composition api` система реактивности больше не привязана к компонентам, что позволяет использовать её в любых частях приложения и качественно декомпозировать код. Кроме того, в отличие от React, в котором изменение реактивного состояния приводит к перерисовке (redraw) компонента, в котором это состояние объявлено, и всех его дочерних в глубину, изменение состояния в Vue приводит к перерисовке только тех компонентов, которые это состояние используют, что в разы эффективнее с точки зрения производительности. В React в данный момент тоже добавляют аналогичный функционал (React Signals), однако он ещё в экспериментальной стадии и многие плагины и библиотеки его не поддерживают. В остальном, Vue не отстаёт от React, и выбор между этими двумя инструментами становится более сложным @ouchaib2024benchmarking. Для решения этой задачи использовалась системой поддержки принятия решений, которая позволила выбрать оптимальный инструмент для решения задачи.

Фреймворки оценивались по следующим критериям:
- Производительность рендеринга — насколько эффективно фреймворк обновляет DOM. Использование Virtual DOM, скорость перерисовки, способность обрабатывать большое количество изменений.
- Размер бандла — какой размер занимает фреймворк после компиляции. Важно для скорости загрузки страницы.
- TypeScript — насколько хорошо фреймворк поддерживает TypeScript, написан ли он сам на TypeScript.
- Встроенные возможности — наличие встроенных возможностей, таких как маршрутизация, управление состоянием. Можно ли пользоваться фреймворком без сторонних библиотек.
- Реактивность — удобство и эффективность работы реактивности.
- Минимальные зависимости — сколько дополнительных зависимостей (библиотек) используется во фреймворке. Чем меньше зависимостей, тем меньше вероятность появления ошибок и уязвимостей.
- Стабильность API — устойчивость фреймворка в долгосрочной перспективе, совместимость версий. Открытый или закрытый проект.
- Инструменты разработки — наличие и удобство инструментов разработки, таких как просмотр компонентов и состояний.
- Документация, сообщество — насколько хорошо написана документация, размер и активность сообщества, количество библиотек.

С использованием пяти алгоритмов был рассчитан общий балл для каждого облачного провайдера. В #ref(<sppr-framework-report>, supplement: "приложении") находится подробный отчёт СППР.

#figure(caption: [Результат работы СППР выбора фреймворка])[
  #show table.cell.where(y: 0): set text(weight: "bold")
  #table(
    columns: (auto, auto, auto, auto, auto, auto, auto, auto),
    align: horizon,
    table.header([Вариант], [Дом], [Блок], [Тур], [Sjp], [Sjm], [ИТОГО], [Место]),
    [*Vue3*], [4], [3], [4], [4], [3], [18], [1],
    [*React*], [3], [2], [3], [3], [2], [13], [3],
    [*Angular*], [1], [1], [1], [1], [1], [5], [4],
    [*Svelte*], [2], [4], [2], [2], [4], [14], [2],
  )
]<sppr-framework-result>

Как видно из таблицы #ref(<sppr-framework-result>, supplement: none), Vue3 является самым оптимальным выбором для реализации веб-карты с большим отрывом. React и Svelte набрали примерно одинаковое количество баллов, Svelte вышел вперёд за счёт высокой производительности и отсутствия внешних зависимостей. Angular сильно отстаёт от всех остальных фреймворков, и его использование не рекомендуется.

Таким образом, для реализации интерфейса веб-карты был выбран Vue3.

=== Отображение карты

Выбранный фреймворк Vue3 позволяет удобно работать с компонентами пользовательского интерфейса, однако, кроме интерфейса, приложение должно отображать интерактивные карты. Для этого можно использовать готовую картографическую библиотеку, такую как MapboxGL, Leaflet, OpenLayers и другие. Однако у всех библиотек очень ограничен функционал добавления наложения (overlay) слоёв и аннотаций. В основном, функционал наложения в таких библиотеках предназначен для отображения небольших полигонов или одиночных маршрутов; в случае с PolyMap, карты состоят из тысяч полигонов, которые необходимо отображать одновременно. Для такого необходимо использовать графический ускоритель (GPU), из браузера это можно сделать с помощью WebGL. Поддержку WebGL-наложений предоставляют всего несколько библиотек: MapboxGL, MapLibreGL, Google Maps (позволяет получить контекст WebGL и рисовать самостоятельно). Однако создавать собственные аннотации с анимациями крайне проблематично во всех библиотеках.

Исходя из того, что основным функционалом PolyMap является отображение карты, принято решение отказаться от использования сторонних библиотек в пользу своей реализации, адаптированной под нужды и задачи PolyMap, которая будет наиболее эффективно выполнять задачи сервиса. Это позволило добиться максимальной эффективности и избежать избыточного функционала, способного замедлить работу приложения.

Для оптимального отображения карты необходимо использовать WebGL, так как он позволяет использовать графический ускоритель (GPU). Работать с WebGL можно напрямую через графический контекст и низкоуровневый API, а можно использовать минимальные библиотеки, которые уже реализуют базовый графический Pipeline. Наиболее популярной и лёгкой библиотекой является ThreeJS — она позволяет работать с 3D-графикой, а также предоставляет удобный интерфейс для работы с WebGL. В текущей версии PolyMap карта имеет 2D-отображение, чего можно достичь ортографической проекцией сверху вниз. В будущих обновлениях планируется добавить поддержку 3D-отображения карты, что является ещё одним аргументом использования 3D pipeline'а с самого начала.

Общий процесс отрисовки 3D-графики в WebGL состоит из следующих этапов:
+ В видеокарту загружаются:
  - вершинный шейдер (vertex shader) — программа на `GLSL`, которая выполняется на GPU и отвечает за преобразование вершин в экранные координаты. Вызывается для каждой вершины в буфере вершин (vertex buffer) в пространственных координатах.
  - фрагментный шейдер (fragment shader) — программа на `GLSL`, которая выполняется на GPU и отвечает за определение цвета пикселя на экране. Вызывается для каждого пикселя внутри треугольника в экранных координатах.
  - юниформы (uniforms) — глобальные переменные, которые передаются в шейдеры и не меняются в процессе отрисовки. Например, матрица проекции, матрица вида, текстуры и другие пользовательские данные, определённые в шейдере.
+ В видеокарту загружается буфер вершин (vertex buffer), который может быть индексированным или неиндексированным. Индексированный буфер состоит из массива параметров вершин и индексов, которые указывают на вершины для объединения в треугольники. У каждой вершины может быть сколько угодно параметров, которые попадут на вход вершинного шейдера.
+ Выполняется вызов отрисовки (draw call), который указывает, что необходимо запустить отрисовку с использованием загруженных шейдеров и буферов.
+ Весь процесс повторяется для следующего набора вершин и шейдеров.

В ThreeJS для упрощения работы с WebGL эти шаги автоматизированы, и низкоуровневые сущности представлены в виде более высокоуровневых абстракций:
- `Material` — материал, он инкапсулирует в себе вершинный и фрагментный шейдеры и все их параметры (uniforms)
- `Geometry` — геометрия, она определяет набор вершин и их параметры
- `Mesh` — объект, он объединяет `Material` и `Geometry`, с него и начинается процесс отрисовки.

Кроме того, ThreeJS предоставляет абстракцию `Scene`, в которую необходимо добавить все `Mesh`, которые необходимо отрисовать. После чего, вызвав функцию `render`, для всех `Mesh` в `Scene` поочерёдно будет вызвана описанная выше последовательность шагов отрисовки.

С точки зрения производительности, бутылочным горлышком процесса отрисовки является количество вызовов отрисовки (draw calls). Каждый вызов отрисовки требует переключения контекста GPU, очистки старой памяти и загрузки новой, что является медленной операцией (передача данных от CPU к GPU осуществляется через медленную шину данных). Есть два способа уменьшения вызовов отрисовки:
- запекание (batching) — объединение нескольких небольших объектов в один большой @wang2023performance.
- инстансинг (instancing) — отрисовка нескольких одинаковых объектов за один вызов отрисовки.

В случае с картой, необходимо оптимально отрисовывать разные полигоы, а значит необходимо объединение (batching), в ThreeJS оно выполняется на уровне `Geometry` и накладывает ограничение на использование только одного материала (у всех объектов должны быть одни и те же шейдеры, текстуры и параметры). В PolyMap реализовано запекание по категориям Unit'ов, то есть, все многоугольники одного типа (например, газоны, дороги, здания) будут объединены в одну `Geometry` и присвоены одному `Mesh`. Это возможно благодаря тому, что они отображаются одинаковым цветом, а их пересечения могут накладываться друг на друга и отображаться за один проход. На #ref(<spbstu-draw-calls>, supplement: "рисунке") показан процесс отрисовки карты по шагам; на практике, каждый шаг накладывается поверх предыдущего, и в результате получается общая карта. Вся карта отображается за 10-15 шагов в зависимости от наличия многоугольников определённых типов на карте. Благодаря запеканию количество вызовов снижено с примерно 3000 (в зависимости от размера карты) до постоянных 10-15 (в зависимости от количества категорий).

#fig(
  "Процесс отрисовки карты по шагам DrawCalls",
  "../assets/spbstu-draw-calls-steps.png",
  width: 100%,
)<spbstu-draw-calls>

Такая система отрисовки показала себя крайне эффективной: время на один кадр на компьютере 2019 года (с видеокартой Radeon Pro Vega 48) в FullHD-разрешении составляет 1.29 мс при лимите в 16.67 мс на кадр (60 FPS). Измерения проводились с помощью встроенных инструментов Chrome DevTools, на #ref(<map-draw-performance>, supplement: "рисунке") видно, что время вызова функции `requestAnimationFrame`, которая каждый кадр запускает отрисовку карты, составляет 1.29 мс.

#fig(
  "Диаграмма времени отрисовки одного кадра карты",
  "../assets/map-draw-performance.png",
  width: 100%,
)<map-draw-performance>

=== Отображение аннотаций
После общей геометрии карты по значимости идут аннотации: они добавляют карте информативности, с их помощью подписываются здания, входы, парковки, номера кабинетов, столовые. По аннотациям пользователь сможет проводить поиск и строить маршруты между ними. В отличие от статичной геометрии карты, аннотации являются частью пользовательского интерфейса. Каждая аннотация привязана к точке на карте в экранном пространстве. Размер и горизонт аннотации являются неизменными при масштабировании и вращении карты. На аннотациях присутствует текст, и они должны реагировать на пользовательский ввод. Все эти факторы накладывают серьёзные ограничения на систему отрисовки аннотаций.

Основной способ отображения 2D пользовательского интерфейса в вебе — это использование HTML-элементов; в случае с аннотациями нужно было бы использовать аннотации в абсолютных координатах, которые бы обновлялись каждый кадр. Однако это крайне неэффективно, так как время отображения HTML-элементов экспоненциально растёт с их количеством. Поэтому в PolyMap аннотации отображаются с помощью Canvas API, который позволяет императивно рисовать 2D-графику на растровом холсте; в этом случае производительность зависит от количества элементов линейно.

#fig(
  "Диаграмма классов системы аннотаций",
  "../assets/annotation/diagram.png",
  width: 80%,
)<annotation-uml>

В сервисе присутствуют три вида аннотаций:
- `Occupant Annotation` — самая базовая аннотация, с её помощью отображаются предназначения кабинетов внутри здания: например, номер лектория, название столовой, конференц-зала и т.д.
- `Amenity Annotation` — аннотация, которая отображает дополнительные удобства внутри здания, например, лестницы, лифты, входы и выходы, а также удобства вне здания, такие как парковки, велопарковки, спортивные площадки и т.д.
- `Attraction Annotation` — аннотация, которая отображает точки интереса вне здания. В первую очередь такими аннотациями помечаются учебные корпуса.

#subfig(
  figure(image("../assets/annotation/occupant.jpg"), caption: [`Occupant`]),
  figure(image("../assets/annotation/amenity.jpg"), caption: [`Amenity`]),
  figure(image("../assets/annotation/attraction.jpg"), caption: [`Attraction`]),
  columns: (1fr, 1fr, 1fr),
  caption: [Виды аннотаций],
)

У каждой из аннотаций есть несколько состояний, между которыми она может переключаться: например, аннотация может быть активной (выделенной пользователем), закреплённой (в случае прокладывания маршрута) или в минимизированном состоянии (отображается маленькой точкой). Все аннотации наследуются от класса `AnimatedAnnotation`, который упрощает переходы между состояниями. У аннотаций есть уровень детализации, который определяет значимость аннотации. Базовый класс `DetailLevelAnnotation` управляет состоянием в зависимости от текущего контекста карты: учитываются состояния аннотации, масштаб карты, наличие аннотаций поблизости. В конечном итоге все аннотации являются потомками класса `Annotation`, который реализует интерфейс `IAnnotation`, через который аннотации добавляются на карту.

#subfig(
  figure(image("../assets/annotation/states/dot.jpg"), caption: [`Точка`]),
  figure(image("../assets/annotation/states/circle-image.jpg"), caption: [`Иконка`]),
  figure(image("../assets/annotation/states/label.jpg"), caption: [`Подпись`]),
  figure(image("../assets/annotation/states/pin.jpg"), caption: [`Маршрут`]),
  figure(image("../assets/annotation/states/selected.jpg"), caption: [`Выделенная`]),
  columns: (1fr, 1fr, 1fr, 1fr, 1fr),
  caption: [Виды состояний аннотаций],
)

Ответственность за отображение аннотаций в разных состояниях лежит на конечной реализации трёх видов аннотаций, которые переопределяют метод `draw(ctx: Context2D)`. Кроме этого, каждая аннотация должна определить свой `BoundingBox` — прямоугольник, внутри которого будет отрисовываться, и `frame` — прямоугольник, по нажатию на который аннотация будет активироваться. Механизм наследования позволяет переопределить метод `pointInside(position: Vector2D)` для определения, подходит ли точка на экране для активации аннотации. Однако в текущей реализации достаточно использовать `frame` и стандартную реализацию метода `pointInside`.

Процедурная отрисовка графики на процессоре медленнее, чем отрисовка графики на видеокарте; особенно медленной операцией является отрисовка текста. Результат такой отрисовки будет намного качественнее, чем любая альтернатива на видеокарте: именно процессорные алгоритмы позволяют получить наиболее качественное сглаживание. При масштабировании карты аннотации двигаются друг относительно друга, а это означает, что каждую аннотацию нужно каждый кадр перерисовывать в новых координатах.

#fig(
  "Пример двух текстурных атласов",
  "../assets/annotation/atlas.jpg",
  width: 70%,
)<annotation-atlas>

Для оптимизации процесса отрисовки применено кеширование аннотаций и текстовых подписей в текстурные атласы (@annotation-atlas). При повторной перерисовке аннотация не выполняет медленную отрисовку текста и картинки, а просто копирует область пикселей из текстурного атласа в нужные координаты целевого холста (@baked-render): такое копирование является крайне быстрой операцией. Если места на атласе недостаточно, то создаётся новый. Красной рамкой на @annotation-atlas и @baked-render отображаются границы отдельных областей на атласе, которые определяются с помощью `BoundingBox`. У аннотаций в активном и закреплённом состоянии, а также во время анимации перехода между состояниями, отрисовка происходит в обычном режиме, так как в таких состояниях не отображается много аннотаций одновременно и медленная отрисовка не будет заметна пользователю. Кешировать необходимо только те состояния, которые отображаются на экране в больших количествах.

#fig(
  "Пример отображения закешированных аннотаций",
  "../assets/annotation/baked-render.jpg",
  width: 50%,
)<baked-render>

=== Система анимаций
Между состояниями аннотации переходят с анимацией. При процедурной отрисовке анимации тоже необходимо делать процедурно, то есть менять параметры отрисовки и перерисовывать каждый кадр анимации (по умолчанию 60 FPS). Для этого в PolyMap применяется твиннер (tweener) — это класс, который управляет анимациями. Твиннер позволяет декларативно задать анимацию путём указания конечного состояния параметра, времени анимации и функции интерполяции, а после, в произвольный момент времени, запустить анимацию из текущего состояния. Такая система позволяет перейти из любого состояния в целевое, и даже во время проигрывания одной анимации её можно прервать на половине и запустить другую. Например, пользователь выбрал аннотацию и до завершения анимации перехода отменил выделение — вместо ожидания завершения анимации открытия и только после запуска анимации закрытия, твиннер прервёт анимацию открытия на том моменте, на котором она находилась, и из этого положения запустит анимацию закрытия. Это делает карту более отзывчивой для пользователя.

В качестве функции интерполяции в PolyMap используется механизм пружинных анимаций (spring animation). При этом подходе анимация проигрывается так, как будто анимируемый объект прикреплён к пружине, которая тянет его к целевому состоянию @gitter2018fluid. В этом случае траектория движения наиболее приближена к реальности, что делает анимацию более естественной. К сожалению, невозможно одной формулой описать пружинную анимацию: для каждого набора параметров необходимо генерировать новую формулу интерполяции.

Пружинная анимация подчиняется классическому дифференциальному уравнению затухающего гармонического осциллятора для массы $m=1$:
$ m dot.double(x) + c dot(x) + k x = 0, m = 1 $

$ dot.double(x) + c dot(x) + k x = 0 $


Введём две величины: собственная частота без затухания $omega = sqrt(k)$ (частота отклика), коэффициент демпфирования: $zeta = c / (2 sqrt(k))$

Подставим $c = 2 zeta omega$ и $k = omega^2$:
$ dot.double(x) + 2 zeta omega + omega^2 x = 0 $

Найдём решение в форме характеристического уравнения $x(t) = e^(r t)$

$ r^2 + 2 zeta omega r + omega^2 = 0 => r_(1,2) = -zeta omega plus.minus omega sqrt(zeta^2 - 1) $

Величина $Delta = zeta^2 - 1$ даёт нам 3 решения:

\ Недодемпфированный $zeta < 1$:
$
  omega_d = omega sqrt(1 - zeta^2), x(t) = e^(-zeta omega t) [ x_0 cos(omega_d t) + (v_0 + zeta omega x_0) / omega_d sin(omega_d t) ]
$

\ Критически демпфированный $zeta = 1$:
$
  x(t) = e^(-omega t) [ x_0 + (v_0 + omega x_0) t ]
$

\ Передемпфированный $zeta > 1$:
Реальные отрицательные корни:
$ r_(1,2) = -zeta omega plus.minus i omega sqrt(zeta^2 - 1), (r_1 < r_2 < 0) $

Получим:

$ w_d = omega sqrt(zeta^2 - 1), x(t) = e^(-zeta omega t) [с_1 e^(w_d t) + с_2 e^(-w_d t)] $
где
$ c_1 = (v_0 + x_0(zeta omega + omega_d)) / (2 w_d), c_2 = x_0 - c_1 $

Для упрощения в коде введём: $lambda = c / (2m) = zeta omega$, полный исходный код, реализующий пружинную анимацию на TypeScript (@spring-interpolation).

Примеры работы функции пружинной анимации приведены на @byDamping и @byFrequency. На них показано, как меняется кривая анимации в зависимости от изменения коэффициента демпфирования и частоты отклика. Как видно из графиков, продолжительность анимации зависит от частоты отклика, а амплитуда колебаний ("пружинность") — от коэффициента демпфирования. При передаче функции интерполяции в твиннер необходимо учитывать, что пружинная анимация является бесконечно затухающей, а значит, нужно подбирать время анимации так, чтобы обрезать колебания в моменте, когда они становятся менее одного пикселя.

#import "../assets/spring-animatino-plot.typ": byDamping, byFrequency

#figure(caption: [Изменение коэффициента демпфирования $ζ$ при частоте отклика $ω = 0.5$])[
  #byDamping
]<byDamping>

#figure(caption: [Изменение частоты отклика $ω$ при коэффициенте демпфирования $ζ = 0.3$])[
  #byFrequency
]<byFrequency>

=== Поиск маршрутов

Поиск маршрута в PolyMap осуществляется по графу маршрутов с весами (@nav-path-graph). Поиск по графу можно осуществлять с помощью разных алгоритмов; наиболее оптимальным и популярным является алгоритм `A*` (A-star), однако на практике он плохо работает с неравномерными в пространстве графами с весами, что связано с высокой погрешностью эвристической функции @Wilt2021WhenDW. Поэтому в PolyMap для поиска маршрута используется алгоритм Дейкстры, который позволяет находить гарантированно кратчайший путь по графу между двумя точками. Размер графа маршрутов внутри кампуса достаточно мал, поэтому проблем с производительностью не возникает.

#fig(
  "Пример графа маршрутов",
  "../assets/nav-path-graph.png",
  width: 80%,
)<nav-path-graph>

При поиске маршрута с улицы в помещение поиск происходит в два этапа:
+ Поиск маршрута от точки на улице до входа в здание
+ Поиск маршрута от входа в здание до конечной точки внутри здания
Это позволяет снизить число вершин в графе и ускорить поиск: даже если на одной карте будет много зданий, при поиске маршрута будут учитываться только граф вне здания и граф внутри целевого здания. Если здание имеет несколько входов, то будут перепробованы все входы, и отображаться будет наиболее оптимальный маршрут. Отображение маршрута происходит в системе аннотаций на `Canvas`, так как маршрут всего один, значительной нагрузки на CPU он не оказывает и в оптимизации отрисовки не нуждается.

Для расчёта времени маршрута применяется формула #ref(<eq>, supplement: none), где $T$ — время в секундах, $w_k$ — вес отрезка, $d_k$ — длина отрезка, $"type"[k]$ — тип отрезка (внутри здания, вне здания, лестница), $v$ — скорость передвижения по отрезку определённого типа, $C$ — количество переходов между улицей и зданием, $t_C$ — время перехода между улицей и зданием.

$ T = sum_(k=0)^n [(w_k * d_k) / v_("type"[k])] + C * t_C $ <eq>

Экспериментально выяснено, что скорость передвижения вне здания составляет $4.5 "км/ч"$, внутри здания $3.5 "км/ч"$, по лестнице $1.5 "км/ч"$, а время перехода между улицей и зданием составляет $t_C = 60 "с"$.

=== Энергоэффективность
Так как приложение предназначено не только для компьютеров, но и для мобильных устройств, необходимо учитывать энергопотребление. Использование графических ускорителей на мобильных устройствах задействует высокопроизводительные ядра системы на чипе, что приводит к повышенному энергопотреблению. Для снижения энергопотребления в PolyMap реализована условная перерисовка карты: во время взаимодействия с картой и анимаций, например, при прокрутке или изменении масштаба, карта перерисовывается с частотой 60 FPS, а в статичном состоянии карта не перерисовывается вовсе, а на экране остаётся последний кадр, что позволяет снизить число обращений к графическому ускорителю примерно в 2-3 раза (на основе практических измерений взаимодействия с картой). Также, в сценариях поиска по аннотациям и использования прочего пользовательского интерфейса, число вызовов отрисовки снижается в 10 раз.

На @dynamic-fps-profiler показан профайлер Chrome DevTools, на котором отображается 8 секунд использования приложения; за это время было проведено два панорамирования карты и одно приближение. На верхней шкале отображается общая нагрузка: из графика видно, что нагрузка присутствует во время взаимодействия с картой, и практически отсутствует между действиями. Из шкалы `Frames` видно, что между взаимодействиями частота кадров замораживалась, а во время взаимодействия частота кадров была 60 FPS (график зелёный; в случае превышения нагрузки и падения ниже 60 FPS кадры отображаются оранжевым цветом). Аналогичная картина видна и на шкале использования основного ядра `Main` и графического ускорителя `GPU`. Хоть на них и присутствуют деления, они связаны не с отрисовкой карты, а с композицией HTML-интерфейса (compositing), который оставался динамическим всё время использования приложения.

#fig(
  "Диаграмма нагрузки во время использования приложения",
  "../assets/dynamic-fps-profiler.png",
  width: 100%,
)<dynamic-fps-profiler>

=== Хостинг
Несмотря на то, что веб-карта является веб-приложением (фронтендом), его всё ещё необходимо хранить на сервере и раздавать пользователям по GET-запросам на домен карты. В выбранной инфраструктуре Yandex Cloud для хостинга статичных сайтов можно использовать Yandex Object Storage (S3). Он позволяет настроить бакет в режиме веб-сайта (@s3-web-hosting), в этом случае бакет станет доступен из интернета по служебному домену, после чего в настройках DNS нужно будет добавить CNAME-запись, которая будет указывать на бакет (@dns-s3-cname). В этом случае даже не нужно использовать API Gateway, так как S3 в режиме веб-сайта будет самостоятельно раздавать статичные файлы по HTTP-запросам.

#fig("Настройки Object Storage в режиме веб-сайта", "../assets/s3-web-hosting.png", width: 80%)<s3-web-hosting>
#fig("Настройки DNS для работы веб-сайта на Object Storage", "../assets/dns-s3-cname.png", width: 80%)<dns-s3-cname>

Чтобы не создавать излишнюю нагрузку на Object Storage (каждый запрос тарифицируется), рационально использовать CDN. Для этого нужно загружать статичные файлы в бакет с указанием заголовков `Cache-Control`; в этом случае Object Storage будет добавлять эти заголовки к ответам, и CDN будет кешировать файлы.

#listing("Пример загрузки в Object Storage с указанием заголовков Cache-Control")[
  ```sh
  aws --endpoint-url=https://storage.yandexcloud.net/ \
    s3 cp .output/public s3://polymap.io/ \
    --recursive \
    --cache-control 'max-age=864000' \
    --profile polymap
  ```
]

Такой хостинг получается крайне дешевым, а в большинстве случаев и бесплатным, так как используемые ресурсы не превышают бесплатный лимит. При этом Object Storage гарантирует высокую доступность и отказоустойчивость, а также возможность масштабирования. В дополнение к этому, Yandex Cloud предоставляет продвинутый мониторинг полностью бесплатно: он настроен по умолчанию и позволяет отслеживать количество запросов, ошибки, время ответа.

#fig(
  "Пример работы мониторинга Object Storage",
  "../assets/s3-web-hosting-monitoring.png",
  width: 100%,
)<s3-web-hosting-monitoring>

=== Результат
В результате разработки было получено веб-приложение для отображения интерактивной карты, которое позволяет пользователю:
- Просматривать геометрию карты — как внутри зданий, так и вне
- Просматривать аннотации на карте
- Проводить поиск по аннотациям
- Прокладывать маршруты между аннотациями, в том числе между улицей и зданием
- Просматривать информацию о выделенной аннотации

Приложение полностью адаптировано под мобильные устройства и позволяет пользователю взаимодействовать с картой с помощью жестов, таких как прокрутка, масштабирование и поворот, а также использовать 2D интерфейс приложения. На компьютерной версии он отображается в виде прямоугольной панели в левой части экрана, а на мобильной версии — в виде плавающей панели внизу экрана, которую можно вытянуть вверх на весь экран, свернуть вниз или оставить посередине экрана, как на #ref(<polymap-mobile-web>, supplement: "рисунке").

#subfig(
  figure(image("../assets/polymap-web-ios.jpg"), caption: [Мобильная версия]),
  <polymap-mobile-web>,
  figure(image("../assets/polymap-web.png"), caption: [Компьютерная версия]),
  columns: (1fr, 2.65fr),
  caption: [Веб-версия PolyMap на примере карты кампуса СПбПУ, планировка здания НИК],
)

== Серверная часть
В сервисе используется микросервисная архитектура, и благодаря хорошей декомпозиции (@microservices), реализация каждого микросервиса в отдельности не представляет сложности и не обладает уникальными особенностями, о которых можно было бы рассказать. Однако есть некоторые общие аспекты, которые применимы ко всем реализованным микросервисам. Рассмотрим их в этом разделе.

=== Стек технологий<serverless-technology-stack>
Как упоминалось ранее, одним из ограничений Serverless-подхода является требование к быстрому холодному старту (время между началом запуска Docker-контейнера и моментом, когда сервер будет готов слушать указанный порт). Это создаёт дополнительные нестандартные условия при выборе технологического стека. Благодаря использованию Serverless Containers можно использовать любой стек, который подойдёт для реализации, не ограничиваясь поддерживаемыми языками облака.

Наиболее популярные стеки для бэкенда в 2025 году:
- Java + Spring Boot — постепенно теряет популярность, высокое время холодного старта
- C\# + ASP.NET Core — популярный стек, высокое время холодного старта
- Python + Flask — набирает популярность, применяется в Serverless, но мало инструментов
- Node.js + Express — популярный стек, быстрый холодный старт, много инструментов, адаптированных под Serverless

В качестве языка программирования для бэкенда выбран `TypeScript`. Это крайне популярный язык, у него хорошая поддержка, наибольшее число библиотек, он статически типизирован и обладает комфортным синтаксисом, а так же для него много специалистов. При работе с бэкендом запускать `TypeScript`-код принято через `Node.js`, предварительно скомпилировав его в `JavaScript`. Существует множество фреймворков для разработки веб-сервера на `Node.js`. Благодаря хорошей модульности и изолированности частей проекта, никаких специфичных требований для построения больших архитектур к фреймворку не предъявляется. Основной критерий выбора — скорость холодного старта и поддержка сообщества (популярность).

В настоящее время существует три основных рантайма выполнения `JavaScript`:
- Node.js — самый первый и наиболее популярный, использует движок V8
- Deno — новый рантайм, который использует V8, но с поддержкой ES-модулей и TypeScript из коробки
- Bun — новый инструмент с новым подходом, целью которого является максимальная производительность выполнения кода, а так же предоставление разработчику других высокопроизводительных инструментов.

Было принято решение попробовать использовать современный и многообещающий `Bun`. Производительность достигается за счёт использования движка JavaScriptCore, разработанного Apple для Safari (движок с открытым исходным кодом), а также за счёт использования языка программирования Zig с применением низкоуровневых оптимизаций. Кроме того, Bun представляет собой инструмент "всё в одном", который включает в себя пакетный менеджер, сборщик, рантайм, поддержку тестов, запуск TypeScript и JSX из коробки, а также ряд полезных встроенных библиотек (PostgreSQL driver, SQLite driver, S3 Cloud Storage driver, Redis client, WebSocket server (включая pub/sub), HTTP server, HTTP router). Каждая из этих библиотек является прослойкой к низкоуровневому и очень хорошо оптимизированному коду на Zig. В результате все базовые возможности работают в разы быстрее аналогичных JS-библиотек для Node или Deno @Ostretsova2025COMPARATIVEAO.

Рантайм практически полностью совместим с API Node.js, и подавляющее число Node.js-библиотек будут корректно работать в Bun. Все популярные библиотеки адаптированы под Bun. Кроме того, вокруг Bun сложилась экосистема библиотек и инструментов, которые были разработаны с философией максимальной производительности, достигаемой за счёт использования высоко оптимизированного API Bun.

#include "../assets/bun-node-deno.typ"

Кроме рантайма, нужно ещё выбрать фреймворк для удобства создания REST API-сервера. Большинство фреймворков предоставляют очень похожий синтаксис, поэтому наиболее важным критерием являются производительность и скорость холодного старта. Наиболее популярные быстрые фреймворки:
- Fastify — один из самых быстрых фреймворков, поддерживает все популярные плагины, имеет хорошую документацию и сообщество
- Express — самый популярный, но наиболее медленный фреймворк
- Hono — самый быстрый фреймворк, разработанный специально для Bun и Serverless
- Elysia — новый быстрый фреймворк, разработанный для Bun

Для выбора фреймворка было проведено тестирование времени ответа в разных сценариях холодного и горячего старта. Тестирование проводилось на реальной инфраструктуре Yandex Cloud с использованием Serverless Containers. Результаты тестирования приведены в @serverless-cold-start-framework.

В ходе тестирования было выяснено, что кроме фреймворка и рантайма, на время холодного старта влияет базовый образ Docker-контейнера (а точнее его размер), а также применение бандлера и сам бандлер. Бандлер позволяет собрать весь исходный код в один файл (в том числе библиотеки), а также минимизировать его. Это позволяет сократить время загрузки и парсинга исходного кода. Современные бандлеры используют механизм Tree Shaking, который позволяет удалить неиспользуемый код из бандла, что крайне эффективно при использовании библиотек. При сравнении были проведены тесты с использованием разных бандлеров (ESBuild, Parcel, Rollup, Webpack, Bun bundler) и без них. Тесты проводились на микросервисе генерации QR-кодов и на тестовом микросервисе с большим числом библиотек, что делает результаты более репрезентативными.

В результате был выбран следующий подход:
- Bun в качестве рантайма
- TypeScript в качестве языка программирования
- Hono в качестве фреймворка
- Bun bundler в качестве бандлера
- Distroless в качестве базового образа Docker-контейнера (является наиболее урезанным образом Linux, в котором нет ничего лишнего; базовый образ занимает всего 9 МБ вместо 16 МБ у Alpine)

=== Шаблон микросервиса
Для удобства создания микросервисов был создан шаблон микросервиса, который можно копировать и использовать в качестве основы для новых микросервисов. Шаблон включает в себя:
- Настроенный Bun-проект с пакетным менеджером и сборщиком
- Установленный `Hono`-фреймворк и пример `echo` (отвечает на запросы `GET /api/echo/:message` сообщением `Hello :message`)
- Настроенный Dockerfile, который собирает проект в Docker-образ
- Настроенный GitHub Actions, подробнее описан в #ref(<ci-cd-pipeline>, supplement: "разделе")
- Настроенный Terraform-проект, который разворачивает микросервис в Yandex Cloud:
  - Компиляция микросервиса в Docker-образ
  - Загрузка Docker-образа в Yandex Container Registry
  - Создание Serverless Container в Yandex Cloud
  - Создание API Gateway в Yandex Cloud. Описан шаблон OpenAPI-спецификации.
- Настроенный ESLint @eslint для оценки качества кода, подробнее в #ref(<code-quality-check>, supplement: "разделе")
- Настроенные модульные тесты с использованием `bun test`, подробнее в #ref(<unit-tests>, supplement: "разделе")
- Настроенные Cypress E2E-тесты, подробнее в #ref(<e2e-tests>, supplement: "разделе")

Таким образом, для создания нового микросервиса достаточно скопировать шаблон, задать название проекта и подключить его к организации в GitHub. Сразу после первого коммита запустится CI/CD-процесс, который развернёт этот микросервис в тестовом окружении.

После чего программисту остаётся только писать реализацию кода, модульные и E2E-тесты и вносить изменения в OpenAPI-спецификацию. Все настройки, конфигурации и инфраструктура уже готовы в шаблоне и не требуют дополнительных действий. Такой подход значительно ускоряет разработку, не требует повторения рутинных действий и гарантирует единообразие кода по всему проекту.

=== Раздача карт и CDN
Одной из особенностей архитектуры PolyMap является оптимизация раздачи статических файлов через CDN. В случае с фронтендом фреймворк Vue в момент компиляции генерирует скрипты с названиями в виде хеш-функции от их содержимого, что делает их полностью статическими файлами. Никаких сложностей с использованием CDN не возникает, эти файлы хранятся в Yandex Object Storage с указанием заголовков `Cache-Control`, на время которого и кешируются в CDN. При обновлении фронтенда происходит его перекомпиляция, и изменённые файлы результата имеют другое название, что позволяет отличить их от старых закешированных версий.

Однако кроме фронтенда, значимое потребление трафика происходит при раздаче файлов карт. Этот процесс тоже оптимизирован через CDN, но карты не являются полностью статическими файлами. В случае изменения (обновления) карты название файла остаётся прежним, и необходим способ максимально быстро доставить новую карту до пользователей. Один из подходов — использовать короткое время кеширования, например 1 час. В этом случае при обновлении карты пользователи получат новую версию в течение одного часа после обновления. Такой подход решит проблему, но создаст излишнюю нагрузку на сервер и замедлит часть запросов, которые будут идти в обход кеша. В большинстве случаев карты меняются значительно реже одного часа. Поэтому в PolyMap используется другой подход при обновлении карты: после обновления микросервис `map-storage`, который отвечает за управление картами, отправляет в CDN-систему по API запрос с указанием URL карты, кеш которой нужно инвалидировать. CDN-система удаляет кеш для этого URL, и при следующем запросе будет получена и закеширована новая версия карты. Это позволяет мгновенно доставлять до пользователей обновления, при этом оставляя большое время кеширования.

#listing("Пример запроса на инвалидирование кеша в CDN")[
  ```bash
  curl -X POST \
    "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/purge_cache" \
    -H "Authorization: Bearer $CF_API_TOKEN" \
    -H "Content-Type: application/json" \
    --data '{ "files": [ "https://map-storage.polymap.io/$MAP_ID" ] }'
  ```
]

== Мониторинг<monitoring>
Мониторинг — важная часть любого программного продукта, крайне важно не только опубликовать систему, но ещё и отслеживать её состояние, время отклика, ошибки, число пользователей и нагрузку на систему. В случае возникновения ошибок полезно иметь логирование, по которому можно будет понять, что именно привело к ошибке.

При использовании Serverless-подхода в Yandex Cloud мониторинг и логирование уже встроены в облако и не требуют дополнительных действий для настройки. Кроме того, мониторинг является полностью бесплатным, а логирование тарифицируется по количеству хранимых записей; в большинстве случаев хватает бесплатных квот.

=== Логирование
Для логирования используется Yandex Cloud Logging, который позволяет:
- Хранить логи от всех внутренних ресурсов Yandex Cloud
- Создавать лог-группы, в которые можно отправлять логи из внешних источников
- Использовать фильтры по логам
- Использовать структурированные JSON-логи
- Хранить логи в Object Storage
- Использовать интеграцию с Grafana
- Настраивать права доступа к логам для разных групп

#fig(
  "Пример логов в Yandex Cloud Logging",
  "../assets/yandex-logging.png",
  width: 80%,
)

=== Мониторинг
Для мониторинга используется Yandex Monitoring, который позволяет собирать, хранить и отображать метрики. По дизайну и функционалу близок к Grafana и Prometheus. Позволяет:
- Автоматически собирать метрики со всех ресурсов Yandex Cloud
- Создавать свои графики и дашборды
- Использовать уже настроенные дашборды для внутренних ресурсов Yandex Cloud
- Использовать API для выгрузки данных
- Создавать собственные метрики

#fig(
  "Пример работы Yandex Monitoring",
  "../assets/yandex-monitoring.jpg",
  width: 80%,
)

=== Алертинг
Сервис мониторинга позволяет настраивать уведомления при достижении пороговых значений метрик. Уведомления могут приходить через различные каналы: Email, Telegram, SMS. Алертинг позволяет максимально быстро реагировать на нестандартное поведение системы, своевременно исправлять ошибки и узнавать о неожиданных ситуациях.

На #ref(<yandex-alerting>, supplement: "рисунке") показан пример уведомления от Yandex Monitoring о превышении порога числа запросов в секунду на сервис API Gateway. Превышение было зафиксировано во время проведения нагрузочного тестирования. Уведомление приходит в момент превышения порога, а также после нормализации. В отчёте о нормализации можно увидеть график числа запросов, время, когда был превышен установленный порог, и момент возвращения показателя в норму.

#fig(
  "Пример уведомления от Yandex Monitoring о превышении порога числа запросов в секунду",
  "../assets/yandex-alerting.png",
  width: 60%,
)<yandex-alerting>

== Вывод

В данной главе были рассмотрены основные аспекты реализации сервиса: в качестве системы управления версиями выбран GitHub, определён стек технологий для клиентской части — Vue 3 + TypeScript, для серверной части — Bun + TypeScript + Hono.

Рассмотрены некоторые детали реализации основного функционала проекта — веб-версии карты, описан процесс запекания геометрии для оптимизации GPU, рассмотрен процесс запекания аннотаций, а также их система пружинных анимаций, описан механизм повышения энергоэффективности с помощью динамической частоты кадров. Описан хостинг статичных файлов в Yandex Object Storage с использованием CDN для оптимизации раздачи файлов и система инвалидации.

Рассмотрен процесс разработки микросервисов с использованием разработанного шаблона. Описана система мониторинга, включающая в себя логирование, мониторинг и алертинг.
= Тестирование и оценка качества кода

== Непрерывная интеграция и развёртывание (CI/CD)
При разработке по микросервисной архитектуре крайне важно на самых ранних этапах автоматизировать процесс сборки и развёртывания приложения. Это обусловлено тем, что при такой архитектуре появляется множество проектов с частыми обновлениями, автоматизация рутинных процессов позволяет снизить количество ошибок, которые могут возникнуть при ручном развёртывании, а также позволяет добавить автоматизированные тесты для контроля качества кода с самых ранних этапов.

=== GitHub Actions
В выбранной системе контроля версий GitHub для автоматизации процессов сборки и развёртывания используется встроенный инструмент GitHub Actions. С его помощью можно настроить различные автоматические процессы, которые будут запускаться при определённых действиях в репозитории. Процессы могут состоять из нескольких последовательных и параллельных шагов.

Процессы запускаются на определённом GitHub Runner'е, который может быть как облачным, так и локальным. В PolyMap используются облачные GitHub Runner'ы, в качестве операционной системы используется Ubuntu 22.04. GitHub Actions позволяет запускать процессы на Windows и MacOS, однако в этом нет необходимости, весь мой стек технологий прекрасно работает на Linux.

Кроме того, GitHub Actions обладают большим количеством готовых интеграций, которые можно найти в GitHub Marketplace и использовать в своих процессах автоматизации.

Процессы состоят из задач (`jobs`), каждая задача состоит из шагов (`steps`). Шаги запускаются последовательно друг за другом, задачи — параллельно, однако задачам можно указать зависимости, и следующая задача будет запускаться только после завершения всех зависимостей.

=== Infrastructure as Code (IAC)
Для автоматизации развёртывания приложений в CloudNative-среде можно использовать IAC (Infrastructure as Code) подход @IaC. Он позволяет декларативно описать инфраструктуру в виде кода, который можно хранить рядом с кодом приложения в системе контроля версий. Это позволяет версионировать инфраструктуру вместе с кодом приложения, что, в свою очередь, позволяет откатить инфраструктуру к предыдущей версии, если в ней были внесены ошибки. Также такой подход сильно упрощает развёртывание для Serverless-приложений, которые состоят из множества ресурсов, которые необходимо связать между собой.

=== Terraform
Для реализации IAC-подхода наиболее популярным инструментом является Terraform. Все облачные провайдеры в первую очередь добавляют поддержку именно этого инструмента, в том числе и Yandex Cloud, который используется в PolyMap.

В Terraform инфраструктура описывается кодом на специальном языке HCL (HashiCorp Configuration Language). Базовой сущностью в Terraform является ресурс, который описывает отдельный компонент инфраструктуры (Api Gateway, Serverless Container, Docker Registry). Внутри блока ресурса описываются его параметры. Внутри одного Terraform-проекта, ресурсы могут свободно ссылаться друг на друга @Kyadasu2025ExploringIA. Например, ресурс Serverless Container должен в своих параметрах ссылаться на ресурс Docker Registry, в котором хранится образ контейнера.

#listing("Пример использования Terraform")[
  ```tf
  resource "yandex_container_registry" "registry" {
    folder_id = var.folder_id
  }

  resource "docker_image" "main" {
    name = "cr.yandex/${yandex_container_registry.registry.id}/main:latest"
    build { context = abspath(local.app_path) }
    triggers = { hash = local.project_files_hash }
  }

  resource "docker_registry_image" "registry" { name = docker_image.main.name }

  resource "yandex_serverless_container" "container" {
    name               = local.project_name
    folder_id          = var.folder_id
    memory             = 128
    cores              = 1
    core_fraction      = 5
    concurrency        = 16

    image {
      url = docker_registry_image.registry.name
      digest = docker_registry_image.registry.sha256_digest
      environment = merge(var.container_env, { "LOG_VARIANT" = "JSON" })
    }

    depends_on = [...]
  }

  resource "yandex_api_gateway" "gateway" {
    name        = local.project_name
    folder_id   = var.folder_id

    spec = templatefile("${path.module}/gateway.yaml.tftpl", {
      container_id = yandex_serverless_container.container.id
    })
  }
  ```
]<terraform-example>

В примере выше (@terraform-example) описано пять ресурсов, которых полностью достаточно для микросервиса в Serverless:
+ `yandex_container_registry` — описывает реестр Docker-образов в Yandex Cloud, в котором будут храниться образы контейнеров
+ `docker_image` — описывает образ Docker-контейнера, который будет скомпилирован из директории `local.app_path` при изменении хеша файлов проекта и будет загружен в вышеописанный реестр с тегом `latest`
+ `docker_registry_image` — отвечает за выгрузку образа в реестр (выгрузка определяется по имени образа, который зависит от `id` реестра)
+ `yandex_serverless_container` — описывает Serverless-контейнер, к которому будет привязан `latest`-образ из реестра `yandex_container_registry`, задаёт ему настройки памяти, количество ядер и лимит параллельных запросов (в данном случае контейнер не сможет обрабатывать больше 16 запросов одновременно, при превышении этого лимита будут создаваться новые экземпляры). Также задаются переменные окружения, которые берутся из параметров запуска Terraform, и добавляется дополнительная переменная `LOG_VARIANT`, которая отвечает за формат логов.
+ `yandex_api_gateway` — описывает точку входа в микросервис по спецификации OpenAPI, которая находится в отдельном файле `gateway.yaml.tftpl` (формат `yaml` с поддержкой шаблонизации Terraform). В качестве значений шаблона в спецификацию передаётся `container_id`.

=== Преимущества Serverless в CI/CD
Совместно с использованием Terraform, Serverless-подход обладает важным преимуществом — возможностью *бесплатно* создавать сколько угодно тестовых окружений, которые будут идентичны производственным, но при этом полностью изолированы от внешней инфраструктуры. Это позволяет запускать тестирование на самых ранних этапах разработки и проводить тесты на инфраструктурной среде, неотличимой от производственной. Это существенно снижает количество ошибок, которые возникают из-за разницы в тестовом и производственном окружениях. Например, при Kubernetes-развёртывании тестовое окружение обычно запускают на одном локальном сервере, из-за чего при тестировании не учитываются сетевые задержки между нодами, которые неизбежно возникнут в распределённой системе.

В Yandex Cloud для разделения окружений используются *директории* — это способ изолировать ресурсы друг от друга внутри одного облака. Ресурсы находятся в разных подсетях, к ним применяются разные права доступа, разные IAM-роли, и нет возможности взаимодействовать между ними.

Однако в настоящее время процесс создания и удаления директорий занимает продолжительное время (около 5 минут), что существенно замедляло CI/CD-процесс. Чтобы избежать этого ожидания, был использован классический подход — создание Worker Pool'ов — это группы директорий, которые создаются один раз, а затем переиспользуются по мере необходимости. Для реализации этого подхода был разработан и опубликован в GitHub Marketplace специальный GitHub Action `yandex-cloud-worker-folder-manager` @soprachevYCClear.

#todo[Возможно, лучше использовать https://typst.app/universe/package/chronos/:\ ../assets/yandex-cloud-worker-folder-time-diagram.typ]
// #include "../assets/yandex-cloud-worker-folder-time-diagram.typ"

#fig(
  "Диаграмма последовательности для запроса рабочих директорий",
  "../assets/yandex-cloud-worker-folder-time-diagram.pdf",
  width: 80%,
)<action-directory-worker-diagram>


Рассмотрим механизм его работы в ситуации, когда два микросервиса одновременно запрашивают новое тестовое окружение и попадают в ситуацию гонки:
+ В начале CI/CD-процесса запускается Action, который через API запрашивает в Yandex Cloud список свободных директорий (директории, созданные в рамках пула, определяются по наличию метки `worker-directory`, а свободные — по отсутствию `worker-used-by-*`)
  + Если свободных директорий нет, то Action создаёт новую директорию — это занимает около 5 минут, после чего помечает её меткой `worker-directory`
+ Выбирается случайная свободная директория, и ей устанавливается метка `worker-used-by-<UUID>`, где `<UUID>` — это уникальный идентификатор, сгенерированный в начале CI/CD-процесса на основе репозитория, коммита и места запуска.
+ Происходит ожидание в 10 секунд (этого времени достаточно для установки тега), после чего запрашивается директория с нужной меткой
  + Если такой директории нет, значит другой процесс одновременно с нашим установил свою метку (ситуация гонки), и нужно повторить процесс с самого начала
+ Внутренний ID директории сохраняется в `output` переменной Action'а, которая будет использоваться в следующих шагах CI/CD-процесса
+ После завершения CI/CD-процесса Action удаляет метку `worker-used-by-*` из директории, что позволяет использовать её в других процессах. Есть возможность отключить эту опцию и освобождать директорию не автоматически. Например, если директория запрашивается в момент создания Pull Request'а, то:
  - на всё время, пока PR открыт, за ним будет закреплена определённая директория
  - все GitHub Actions, которые будут запускаться в рамках этого PR, будут использовать эту директорию
  - при закрытии PR нужно сделать отдельный процесс, который будет запускать Action с параметром освобождения директории

Благодаря использованию Serverless-подхода, создание таких рабочих директорий в принципе не требует никаких финансовых затрат, так как весь функционал CI/CD будет генерировать минимальную нагрузку, которая не будет превышать бесплатные квоты.

#listing("Пример запроса рабочей директории в момент открытия PR")[
  ```yaml
  on:
    pull_request:
      types: [opened]

  jobs:
    create-pr-stand:
      runs-on: ubuntu-latest
      steps:
        - name: allocate folder
          id: folder
          uses: soprachevak/yandex-cloud-worker-folder@v1
          with:
            operation: get
            cloudId: ${{ secrets.YC_CLOUD_ID }}
            serviceAccountKeyJson: ${{ secrets.YC_SERVICE_ACCOUNT_KEY_FILE }}

        - name: deploy
          run: echo "FOLDER_ID=${{ steps.folder.outputs.folderId }}"
  ```
]

#listing("Пример освобождения рабочей директории в момент закрытия PR")[
  ```yaml
  on:
    pull_request:
      types: [closed]

  jobs:
    delete-pr-stand:
      runs-on: ubuntu-latest
      steps:
        - name: free folder
          id: folder
          uses: soprachevak/yandex-cloud-worker-folder@v1
          with:
            operation: free
            cloudId: ${{ secrets.YC_CLOUD_ID }}
            serviceAccountKeyJson: ${{ secrets.YC_SERVICE_ACCOUNT_KEY_FILE }}
  ```
]

=== Итоговый CI/CD Pipeline в GitHub Actions<ci-cd-pipeline>

В результате для работы каждого микросервиса было создано несколько CI/CD процессов, которые запускаются на различных этапах:
- На открытие и обновление Pull Request'а — запускает тесты, линтеры, проверяет код на соответствие стандартам, собирает и разворачивает временное тестовое окружение
- На закрытие Pull Request'а — удаляет временное рабочее окружение
- На `push` в ветку `main` — публикует новую версию в производственном окружении
- На `push` в ветку `dev` — публикует новую версию в рабочее окружение

При этом процессы на `push` в ветки `main` и `dev` являются одним и тем же процессом, который запускается с разными параметрами. Это позволяет гарантировать эквивалентность работы микросервиса в производственном и тестовом окружениях.

==== Процесс на открытие Pull Request'а
Запускается на открытие, переоткрытие и обновление Pull Request'а. Самый важный и комплексный процесс.

#listing("Общая структура CI процесса для PR")[
  ```yaml
  on:
    pull_request:
      types: [opened, synchronize, reopened]

  jobs:
    clear_plan_comments: ...
    pr_plan: ...
    unit: ...
    clear_deploy_comments: ...
    get_folder: ...
    terraform: ...
    comment: ...
    e2e: ...
  ```
]

#fig("Диаграмма выполнения CI процесса для PR", "../assets/pr-ci.png", width: 100%)<pr-ci-diagram>

Как видно на диаграмме (@pr-ci-diagram), процесс состоит из двух независимых частей:
+ Процесс проверки и публикации:
  + `Lint and Unit tests` — запускает все виды статических проверок, которые можно выполнить на исходном коде. В частности, запускается линтер, который оценивает качество кода и проверяет его на соответствие стандартам, а также запускаются модульные тесты
  + На этом этапе параллельно запускаются две задачи:
    - `Clear comments` — удаляет старый комментарий с отчётом из текущего PR
    - `Get folder` — запрашивает рабочую директорию в Yandex Cloud
  + `Terraform` — применяет инфраструктуру Terraform в изолированную рабочую директорию из прошлого шага.
  + На этом этапе параллельно запускаются две задачи:
    - `Comment deploy link` — добавляет в PR комментарий с сгенерированным URL на API Gateway рабочей директории (это внутренний служебный поддомен Yandex Cloud, который выдаётся всем API Gateway)
    - `E2E tests` — запускает E2E-тесты, которые запускаются на реальной инфраструктуре в Yandex Cloud. Проверяют корректность работы API, верность ответов и время ответа. На вход получают реальный URL на API Gateway, который был сгенерирован в предыдущем шаге.

+ Комментарий в PR
  + `Clear comments` — удаляет старый комментарий с отчётом из текущего PR
  + `Terraform` — вычисляет Terraform-план, который будет применён в случае принятия Pull Request'а и выводит его в комментарий к PR. Это позволяет проверяющему PR увидеть, какие изменения будут применены к инфраструктуре в случае принятия PR.

В результате выполнения процесса получается отчёт о прохождении всех тестов (@pr-ci-report), в котором описаны проблемы в качестве кода (ESLint), ошибки в модульных тестах (JEST) и результаты E2E-тестов (Cypress). А также, в комментарии к PR добавляется план Terraform, который будет применён в случае принятия PR, и ссылка на API Gateway рабочей директории, с помощью которой можно вручную протестировать изменения (@pr-ci-comment).

#fig("Отчёт о прохождении тестов", "../assets/pr-ci-report.png", width: 100%)<pr-ci-report>
#fig("Комментарий в PR после завершения CI/CD процесса", "../assets/pr-comment.png", width: 100%)<pr-ci-comment>

==== Процесс на применение изменений
Этот процесс занимается применением уже принятых Pull Request'ов в производственное или рабочее окружение. Он запускается на `push` в ветку `main` или `dev`. Процесс упрощён, так как не требует резервирования директории и состоит всего из трёх шагов:
+ Запуск оценки качества кода и Unit-тестов. Несмотря на то, что эти процессы уже были пройдены перед принятием Pull Request'а, их повторный запуск позволяет точно гарантировать отсутствие человеческого фактора (например, принятия PR без учёта CI-проверок). Сам процесс крайне быстрый и практически не влияет на общее время выполнения.
+ Применение Terraform-плана к целевому окружению.
+ Запуск E2E-тестов на целевом окружении, который позволит *гарантировать*, что уже применённые изменения не повлияли на работоспособность сервиса.

#fig(
  "Диаграмма выполнения CI процесса на применение изменений",
  "../assets/dev-ci.png",
  width: 100%,
)<dev-ci-diagram>

== Оценка качества кода
Оценка качества кода — это не менее важный этап разработки, чем тестирование, однако многие разработчики пренебрегают им, из-за чего впоследствии код становится сложным в поддержке, усложняется его понимание, а также увеличивается количество ошибок, которых можно было бы избежать на этапе статического анализа.

В целом, оценка качества кода — это комплексный процесс, и не все этапы могут быть автоматизированы, однако выделяют следующие объективные метрики:
- Читаемость (readability)
  - Ясные и осмысленные имена переменных, функций, классов
  - Чёткая структура и форматирование
  - Отсутствие дублирования кода
- Поддерживаемость (maintainability)
  - Разделение ответственности
  - Модульность архитектуры
  - Чёткая и единообразная структура кода/стиля
- Тестируемость (testability)
  - Наличие модульных, интеграционных, e2e и UI тестов
  - Удобство тестирования (использование DI и интерфейсов)
- Производительность (performance)
  - Использование эффективных алгоритмов и структур данных
- Надёжность (reliability)
  - Обработка исключений
  - Проверка граничных условий
  - Проверка входных данных (от пользователей)
- Безопасность (security)
  - Защита от известных уязвимостей (SQL-инъекции, XSS, CSRF)
  - Разделение прав доступа

=== Применение инструментов оценки качества кода в PolyMap<code-quality-check>
В контексте данной работы сервис PolyMap исполняет практически все требования к качеству кода. Часть требований выполняется автоматически вследствие выбранной архитектуры, а именно:
- вследствие использования микросервисов выполняется разделение ответственности, модульность архитектуры
- вследствие использования CloudNative-подхода выполняется разделение прав доступа (каждый микросервис имеет свой сервисный аккаунт, который имеет доступ только к тем ресурсам, которые необходимы для работы микросервиса)
- использование современных фреймворков и библиотек реализует защиту от известных уязвимостей:
  - параметризация в клиенте для базы данных, защита от SQL-инъекций
  - Hono использует JWT-токены для аутентификации и авторизации, что позволяет избежать CSRF-атак
  - использование VueJS позволяет избежать XSS-атак, так как он экранирует все пользовательские данные (настроен запрет использования директивы `v-html`, которая позволяет вставлять HTML-код в шаблон)
- использование TypeScript позволяет избежать ошибок в коде, связанных с неправильным использованием типов данных. В режиме `strict` проверяются все типы данных, и компилятор предупреждает об ошибках использования типов на этапе компиляции.

Для выполнения остальных требований необходимо использовать специализированные инструменты, в случае с PolyMap это:
- ESLint — статический анализатор кода для JavaScript и TypeScript, позволяет проверять код на соответствие стандартам, на наличие ошибок и потенциальных проблем. В PolyMap во всех проектах используется ESLint с настройками @eslintts:
  - `@typescript-eslint/recommended` — проверяет код на соответствие стандартам TypeScript, а также на наличие ошибок (названия переменных, стилистика кода, неиспользуемые переменные и т.д.).
  - `eslint-plugin-import` — позволяет проверять корректность импортов в проекте.
  - `eslint-plugin-prettier` — позволяет проверять код на соответствие стандартам форматирования кода.
  ESLint запускается в CI/CD-процессе на каждом этапе, и при наличии ошибок процесс останавливается, и Pull Request не может быть принят. Это позволяет гарантировать отсутствие ошибок в коде. Кроме того, при правильной настройке IDE, ESLint работает в реальном времени и отображает ошибки и предупреждения прямо во время написания кода.
- Модульное тестирование — используется во всех микросервисах, запускается в CI/CD-процессе на каждом этапе и в случае ошибок аналогично не позволяет принять PR. В качестве инструмента используется встроенный инструмент BunJS.
- Проверка входных данных в API — используется в каждом микросервисе как middleware для фреймворка Hono. Используется zod-validator, который позволяет проверять входные данные на соответствие заданной схеме и строго типизировать проверенные данные, что на уровне TypeScript гарантирует использование только корректных данных.

#listing("Пример использования zod-validator")[
  ```ts
  const schema = z.object({
     foo: z.string().length(5),
     bar: z.number()
  })

  api.post('/example',
    zValidator('json', schema),
    async (c) => {
      const valid = c.req.valid('json')
      console.log(valid.foo) // string with length 5
      console.log(valid.bar) // number
  })
  ```
]

== Модульное тестирование<unit-tests>

Модульное тестирование — важный этап разработки, он позволяет проверить отдельные части кода на корректность работы. В отличие от интеграционного и e2e тестирования, модульное тестирование проверяет только отдельные функции и классы, без учёта их взаимодействия с другими сервисами. Это позволяет проверить код на соответствие спецификации, однако не гарантирует его корректную работу в реальной среде. Важным преимуществом является скорость выполнения тестов: для них не требуется развёртывать инфраструктуру, и в контексте TypeScript нет необходимости компилировать приложение. В PolyMap все микросервисы используют модульное тестирование с помощью встроенного в Bun инструмента `bun:test` @bunTest. Это быстрый и мощный инструмент, который позволяет запускать TypeScript и JavaScript тесты, по синтаксису совместим с самым популярным тестовым инструментом `jest`, но работает быстрее и имеет дополнительные возможности. Bun Test поддерживает классические тесты, обладает Lifecycle hooks (`beforeAll`, `afterAll`, `beforeEach`, `afterEach`), поддерживает асинхронные тесты, Snapshot testing и Mocking.

#listing("Пример модульного теста Bun test")[
  ```ts
  import { expect, test } from "bun:test";

  test("2 + 2", () => {
    expect(2 + 2).toBe(4);
  });
  ```
]

Для совместимости с тестами код должен быть написан с учётом тестирования, а именно использовать Dependency Injection (DI) и интерфейсы, что позволит легко подменять зависимости в тестах, используя Mock-объекты вместо реальных зависимостей, благодаря чему тесты лучше изолированы друг от друга.

#listing("Пример использования Mock в Bun test")[
  ```ts
  import { test, expect, mock } from "bun:test";
  const random = mock(() => Math.random());

  test("random", async () => {
    const val = random();
    expect(val).toBeGreaterThan(0);
    expect(random).toHaveBeenCalled();
    expect(random).toHaveBeenCalledTimes(1);
  });
  ```
]

Кроме того, Bun test поддерживает Mocking встроенных модулей и npm-пакетов путём подмены модулей в режиме `preload`, благодаря чему обычный `import` модуля получит Mock-версию, а не реальную.

#listing("Пример использования Mock для подмены модуля Bun test")[
  ```ts
  import { test, expect, mock } from "bun:test";

  mock.module("./module", () => {
    return {
      foo: "bar",
    };
  });

  test("mock.module", async () => {
    const esm = await import("./module");
    expect(esm.foo).toBe("bar");

    const cjs = require("./module");
    expect(cjs.foo).toBe("bar");
  });
  ```
]


== UI тестирование
Тестирование пользовательского интерфейса не так популярно, как модульное или интеграционное, это связано с тем, что UI-тесты писать достаточно сложно и выполняются они зачастую медленно, особенно если технология UI не поддерживает такой вид тестов.

В тестировании UI выделяют три подхода:
+ E2E-тестирование (End-to-End testing) — это тестирование всего приложения, которое проверяет его работоспособность с точки зрения пользователя. Инструмент запускает приложение, нажимает на кнопки и проверяет, что на экране присутствуют нужные элементы и тексты. Однако такой подход не учитывает вёрстку и визуальные составляющие (тесты запускаются с отключенным CSS).
+ Тестирование на уровне компонентов (Component testing) — это тестирование отдельных компонентов пользовательского интерфейса, если используется компонентный UI-фреймворк. В случае с PolyMap это VueJS, который является компонентным и поддерживает компонентное тестирование.
+ Тестирование визуального интерфейса (Visual testing) — это тестирование, наиболее приближённое к реальному пользовательскому опыту. Оно проходит по сценариям использования и на каждом шаге делает скриншот приложения, который сравнивается с эталонным. Если скриншот отличается от эталонного, то тест считается проваленным. При хорошем покрытии этот подход позволяет гарантировать, что внесённые изменения повлияли только на ожидаемую часть интерфейса. Например, частой проблемой является внесение изменений в десктопную версию сайта, которые ломают мобильную версию, однако программист, вносящий изменения, мог проверять функционал только на десктопе. Визуальное тестирование позволит избежать таких ошибок.

=== Инструменты тестирования пользовательского интерфейса
В текущий момент на рынке существует три основных инструмента для UI-тестирования:
- Selenium @selenium
- Cypress @cypress
- Playwright @playwright

Рассмотрим каждый из них подробнее с точки зрения пригодности для PolyMap. В частности нас интересует поддержка веб-тестирования, компонентного тестирования для VueJS и возможность запуска тестов в GitHub CI/CD @ricca2024comparative.

==== Selenium
Один из самых старых инструментов для браузерного тестирования, поддерживает множество языков программирования, включая Java, Python, C\# и, в том числе, TypeScript, который нас интересует. Обладает обширной экосистемой, большим числом плагинов, хорошей документацией и самым большим сообществом. Хорошо интегрируется в CI/CD процессы. Позволяет запускать тесты во всех основных браузерах, и даже в устаревшем Internet Explorer. Однако Selenium сам по себе не был предназначен для компонентного тестирования и не поддерживает его. Кроме того, из-за особенностей движка WebDriver, на котором он основан, тесты работают медленно.

#listing("Пример теста на Selenium")[
  ```ts
  import { Builder, By, until } from 'selenium-webdriver';
  import { strict as assert } from 'assert';

  (async () => {
    const driver = await new Builder().forBrowser('chrome').build();
    try {
      await driver.get(URL);
      const incBtn = await driver.findElement(By.css('[data-testid="increment"]'));
      await incBtn.click();

      const countEl = await driver.findElement(By.css('[data-testid="count"]'));
      await driver.wait(until.elementTextIs(countEl, '1'), 2000);
      assert.equal(await countEl.getText(), '1');
    } finally {
      await driver.quit();
    }
  })();
  ```
]

==== Cypress
Современный инструмент для браузерного тестирования, был разработан специально для компонентного тестирования React/Vue/Angular приложений, однако не ограничивается ими. Кроме тестирования интерфейсов, поддерживает и другие виды E2E тестирования, например тестирование REST API. В контексте Vue, Cypress позволяет монтировать компоненты в изолированном окружении без необходимости устанавливать сторонние плагины. К основным преимуществам Cypress относят простоту написания тестов и скорость их выполнения. Тесты выполняются в реальном браузере, том же, что и используется приложением, что позволяет значительно сократить время выполнения тестов. Cypress хорошо поддерживает интеграцию в CI/CD и позволяет записывать видео и делать скриншоты для проваленных тестов, что позволяет оценить, что именно пошло не так. Также Cypress поддерживает режим `time-travel`, который позволяет записывать состояние DOM на каждом шаге выполнения теста и подробно изучать, что привело к ошибке, что крайне полезно для HTML-приложений.
Визуальное тестирование в Cypress достигается с помощью плагина `cypress-image-snapshot`, который позволяет находить разницу между двумя изображениями и определять изменившиеся области.
Обладает обширной документацией и графической средой отладки тестов, что упрощает процесс написания тестов. Поддерживает современные браузеры. Инструмент с открытым исходным кодом.

#listing("Пример теста на Cypress")[
  ```ts
  // E2E
  describe('Counter page', () => {
    it('increments on click', () => {
      cy.visit('/');
      cy.get('[data-testid=count]').should('have.text', '0');
      cy.get('[data-testid=increment]').click();
      cy.get('[data-testid=count]').should('have.text', '1');
    });
  });

  // Component
  import Counter from '@/components/Counter.vue';
  describe('Counter component', () => {
    it('increments on click', () => {
      cy.mount(Counter);                       // mount из @cypress/vue
      cy.get('[data-testid=count]').should('have.text', '0');
      cy.get('[data-testid=increment]').click();
      cy.get('[data-testid=count]').should('have.text', '1');
    });
  });
  ```
]

==== Playwright
Самый новый инструмент из представленных, разработан Microsoft, имеет полностью открытый исходный код. Поддерживает все современные браузеры. Инструмент является многоязычным и поддерживает тесты на Python, Java, C\#, однако основной акцент делается на JavaScript/TypeScript. Playwright не зависит от фреймворка и хорошо поддерживает E2E тестирование интерфейсов, но компонентное тестирование на данный момент является экспериментальной функцией (`@playwright/experimental-ct-vue`), которая не гарантирует стабильность. Это самый быстрый инструмент из представленных, поддерживает многопоточность. В отличие от Cypress, Playwright работает отдельно от браузера через механизмы DevTools, однако всё ещё остаётся быстрым за счёт многопоточности. Лучше всех альтернатив поддерживает визуальное тестирование — все необходимые механизмы для этого уже встроены в инструмент. Также Playwright предоставляет графическое приложение для отслеживания выполнения тестов и записи трасс выполнения. Хорошо работает в CI/CD процессах. Основным недостатком является малое сообщество разработчиков: несмотря на хорошую документацию, далеко не все проблемы могут быть решены с её помощью, и стоит учитывать, что инструмент новый и будет развиваться.

#listing("Пример теста на Playwright")[
  ```ts
  import { test, expect } from '@playwright/test';

  // E2E + Visual testing
  test('increments counter', async ({ page }) => {
    await page.goto('/');
    await expect(page.locator('[data-testid=count]')).toHaveText('0');
    await page.click('[data-testid=increment]');
    await expect(page.locator('[data-testid=count]')).toHaveText('1');

    // Visual testing
    await expect(page).toHaveScreenshot();
  });

  // Component (Experimental)
  import { test, expect } from '@playwright/experimental-ct-vue';
  import Counter from '@/components/Counter.vue';
  test('component increments', async ({ mount }) => {
    const component = await mount(Counter);
    await expect(component.locator('[data-testid=count]')).toHaveText('0');
    await component.locator('[data-testid=increment]').click();
    await expect(component.locator('[data-testid=count]')).toHaveText('1');
  });
  ```
]

==== Выводы
Для проекта PolyMap в качестве инструмента визуального тестирования был выбран Cypress за счёт компромисса между стабильностью и простотой написания тестов. В будущем возможен переход на Playwright, который в техническом плане почти не уступает, однако на данный момент он ещё недостаточно стабилен, не поддерживает компонентное тестирование и не обладает достаточным сообществом разработчиков.

Cypress был интегрирован в CI/CD процесс и запускается на каждый PR, отчёт о прохождении тестов выводится в результат Action'a, в случае проваленных тестов прикладывается короткий видеоролик с выполнением неудачных тестов. Кроме того, Cypress используется и в некоторых микросервисах для тестирования визуального ответа, например, в микросервисе `qr-generator`, который стилизует QR-коды; Cypress позволяет проверить, что QR-код отображается таким, каким он и ожидался (Visual testing). Пример отчёта о прохождении тестов (@pr-ci-report, раздел `Cypress Results`).

== Интеграционное и End to End тестирование<e2e-tests>

Интеграционное тестирование является важным этапом разработки: оно позволяет проверить взаимодействие между различными компонентами системы. В свою очередь, E2E тестирование проверяет работу всей системы в целом на примере определённых сценариев использования. Несмотря на то, что эти типы тестирования проверяют похожие задачи, и проверка взаимодействия между компонентами может быть выполнена в рамках E2E тестов, эти два вида тестирования принято разделять — это связано с проблемами производительности. Для запуска E2E тестов требуется развёртывание всей инфраструктуры, что при классическом подходе требует затрат как времени, так и ресурсов. Интеграционное тестирование же может быть выполнено локально, что быстрее и дешевле, однако это накладывает на программиста ряд дополнительных обязанностей.

Для написания интеграционных тестов приходится использовать Mock-объекты инфраструктуры, то есть, например, вместо реальной базы данных использовать in-memory аналог, реализующий необходимый контракт. Написание и поддержка таких Mock-объектов требует значительных временных затрат разработчика.

Благодаря использованию Serverless- и IAC-подходов к управлению инфраструктурой, в PolyMap удалось избежать написания интеграционных тестов. На каждый PR создаётся реальная инфраструктура в Yandex Cloud, которая, в свою очередь, является полностью изолированной. На этой инфраструктуре можно запускать все необходимые тесты, используя не Mock-объекты, а реальные компоненты Yandex Cloud. Благодаря Serverless такие запуски происходят быстро и не требуют затрат ресурсов. Единственный вид интеграций, который всё ещё требует создания Mock-объектов — это интеграции с другими микросервисами PolyMap, так как инфраструктура является изолированной, и тестируемый микросервис не может взаимодействовать с другими реальными микросервисами. Ещё одним преимуществом такого подхода является возможность оценить не только факт работоспособности интеграции, но и затраченное на выполнение время, которое тоже проверяется в тестах (фактическое время выполнения не должно превышать ожидаемое), что было бы невозможно на локальной Mock-инфраструктуре.

Таким образом, и интеграционное, и E2E тестирование в PolyMap выполняется с помощью одного инструмента — Cypress, который проводит как интеграционные и контрактные тесты, проверяя внешний REST API, так и полноценные E2E тесты по пользовательским сценариям. Входным параметром для Cypress передаётся служебный URL для API Gateway в инфраструктуре Yandex Cloud, таким образом, тесты запускаются не локально, а ходят от GitHub Runner'ов до Yandex Cloud, имитируя реальные действия пользователей. Отчёт о прохождении тестов (@pr-ci-report, раздел `Cypress Results`).

#listing("Пример E2E теста на Cypress")[
  ```ts
  const MAX_RESPONSE_MS = 400;

  describe('QR styling service', () => {
    (['png', 'svg']).forEach((type) => {
      it(`Style for ${type}`, () => {
        cy.request({
          method: 'GET',
          url: `/qr.${type}`,
          qs: params
        }).then((res) => {
          expect(res.status).to.eq(200)
          expect(res.headers['content-type']).to.include(mime(type))
          expect(res.duration).to.be.lessThan(MAX_RESPONSE_MS)

          if (type === 'png') expect(res.body.length).to.be.greaterThan(100)
          else expect(res.body).to.match(/^<svg[^>]*>/)
        })
      })
    })
  })
  ```
]

Кроме этого, в организации GitHub присутствует отдельный репозиторий с E2E тестами всей системы PolyMap, который запускается вручную или по CRON-таймеру раз в сутки и проверяет сценарии использования всей системы. Эти тесты запускаются на производственном окружении и выполняют роль обычного пользователя, убеждаясь, что все основные сценарии использования работают корректно. В случае ошибок создаётся issue в репозитории с описанием проблемы и ссылкой на видео с выполнением теста. Этот процесс не является частью какого-либо CI/CD процесса и не привязан к обновлениям или изменениям в коде. Проблемы могут возникать в любое время даже без вмешательства разработчиков, например, в случае изменения API стороннего сервиса или ошибки со стороны Yandex Cloud. Эти E2E тесты позволяют гарантировать, что в текущий момент вся система работает так, как это и задумывалось.

== Нагрузочное тестирование
Нагрузочное тестирование — это тестирование системы на предмет её производительности и устойчивости к нагрузке. В PolyMap используется бесконечно масштабируемый Serverless-подход, и нагрузочное тестирование не имеет смысла, так как система будет масштабироваться под любую нагрузку, и время ответа будет оставаться близким к константе. Однако использование инструмента нагрузочного тестирования позволяет убедиться в этом, а также проверить, как работает мониторинг и алерты в случае резкого увеличения нагрузки. Подробнее об этом рассмотрено в разделе #ref(<monitoring>, supplement: none).

== Вывод
В данной главе были рассмотрены механизмы тестирования и оценки качества кода в сервисе PolyMap. Были обоснованы выборы инструментов и подходов к тестированию. Рассмотрены способы интеграции тестов и оценки качества кода в CI/CD процессы. В качестве статического анализатора кода был выбран ESLint, модульное тестирование выполняется с помощью встроенного инструмента Bun test, E2E и UI тестирование выполняется с помощью Cypress. Интеграционное тестирование выполняется в рамках E2E тестов, что стало возможным благодаря использованию Serverless-подхода и IAC-подхода к управлению инфраструктурой. Нагрузочное тестирование мало применимо к бесконечно масштабируемому Serverless-подходу, однако в PolyMap с его помощью проверялись корректность работы метрик и алертов.
