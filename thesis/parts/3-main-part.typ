#import "../utils/utils.typ": fig, subfig

= Обзор предметной области
== Актуальность

Обусловлена популярностью пилотной версии PolyMap. В первую неделю учебного семестра, приложением пользовалось более 6000 студентов, что составляет около 80% от всей возможной аудитории.

== Цели и задачи (В введении)

Сервис PolyMap является продолжением бакалаврской работы, в которой была реализована пилотная версия приложения, она обладала следующими ограничениями:
- Поддерживалась только iOS платформа
- Поддерживалась только одна карта Политеха, которая была жёстко закодирована в приложении
- Распространялось в виде приложения, которое требовалось устанавливать на устройство

=== Цели
Цели магистерской работы вытекают из ограничений пилотной версии приложения:
+ Разработать кроссплатформенное решение, которое будет доступно прямо в браузере, и будет адаптировано под управление как с помощью мыши на компьютере, так и с помощью сенсорного экрана на мобильных устройствах.
+ Реализовать возможность динамического просмотра разных карт, которые будут загружаться из удалённого сервера по запросу пользователя.
+ Серверная часть приложения должна справляться с вариативными нагрузками с высокими пиками. Должно быть быстрое время ответа в разных регионах мира.

=== Задачи
Для достижения поставленных целий необходимо решить следующие задачи:
+ Спроектировать и реализовать гибкую клиент-серверную архитектуру приложения
+ Разработать веб-приложение, которое будет отображать интерактивные карты в формате Extended-IMDF (формат карт, используемый в приложении PolyMap)
  + Реализовать мобильную и компьютерную версии приложений.
  + Интерфейс должен быть адаптирован под разные устройства.
  + Управление картой на мобильных устройствах должно поддерживать жесты несколькими пальцами (для вращения и приближения карты).
+ Реализовать серверную часть, которая будет хранить карты и предоставлять их пользователю по запросу, а так же обрабатывать сопутствующие запросы веб-приложения (функция поделиться, генерация QR коров, сокращение ссылок).
+ Добавить в конструктор карт возможность загрузки карты на сервер.






= Архитектура. Serverless подход

== Анализ требований и проектирование
Архитектура сервиса в первую очередь определяется требованиями и задачами, которые перед ней ставятся. Одним из подходов к постановке технического задания является использования пользовательских сценариев. Они позволяют описать требования к системе с точки зрения пользователя, что позволяет лучше понять, как система будет использоваться в реальной жизни.

=== Ролевая модель. Сценарии использования

В сервисе PolyMap выделяются три основные роли:
- *Заказчик* – это человек, который заказывает разработку карты.
- *Пользователь* – это человек, который использует уже созданную карту.
- *Художник* – это человек, который по поручению заказчика оцифровывает карту в конструкторе сервиса.

При этом заказчик и художник могут быть одним и тем же человеком, так как в большинстве случаев, заказчик сам будет оцифровывать карту. Однако, в некоторых случаях, заказчик может поручить эту задачу художнику как своему представителю, так и заказать обрисовку карты у PolyMap.

// TODO: Добавить таблицу User Stories

Таким образом, верхнеуровневую архитектуру сервиса можно представить в виде трёх основных компонентов:
+ Клиентская часть – приложение отображающее интерактивную карту.
+ Конструктор карт – доступен для заказчиков карт и художников, позволяет создавать и редактировать карты, а так же загружать их на сервер.
+ Серверная часть – отвечает за хранение карт и сопутствующих данных, а так же за обработку запросов от клиентской части.

Необходимо предусмотреть возможность расширения клиентской части до нативных мобильных приложения на iOS и Android, а так же возможность в будущем, предоставлять доступ к конструктору карт неограниченному числу лиц.

#fig("Общая схема архитектуры приложения", "../assets/client-server-db.pdf", width: 90%)

== Клиентская часть
Для соответствия требованиям кроссплатформенности, и скорости загрузки, было решено использовать веб-технологии для разработки клиентской части. Это позволит использовать единое веб-приложение как на мобильных устройствах, так и на компьютерах. Кроме того, это позволит избежать необходимости установки приложения на устройство, что значительно упростит процесс использования сервиса и даст пользователям более комфортный опыт (открыть сайт с картой быстрее и безопаснее для пользователя, чем скачивать и устанавливать приложения).

Клиентское веб-приложение всё ещё требует адаптации под разные устройства и способы пользовательского ввода. Для этого необходимо использовать адаптивный интерфейс, который будет подстраиваться под размер экрана устройства, а так же поддерживать способы управления картой мышкой и сенсорным экраном.

Клиентское приложение должно поддерживать следующие функции:
- Отображение карты в формате Extended-IMDF
  - Просмотр карты
  - Приближение и вращение карты
  - Просмотр планировок этажей
  - Переключения между этажами текущего здания
- Отображение аннотаций на карте и этажах
- Поиск по аннотациями на карте
- Просмотр информации об аннотации
  - Текстовое описание аннотации
  - Расположение аннотации на карте
- Построением маршрута по карте
  - Маршрут между двумя аннотациями
  - Маршрут от стандартной точки начала до аннотации (точка начала своя для каждой карты, их может быть несколько)
  - Маршрут должен бесшовно переходить от прилежащей территории к зданию и между этажами
- Должна быть возможность поделиться маршрутом с другими пользователями
  - С помощью постоянной URL ссылки
  - С помощью QR-кода

Подробная реализация будет рассмотрена в @web-map-implementation.

== Конструктор карт
Конструктор карт является отдельным приложением, которое доступно для художников и заказчиков карт после авторизации. В нём можно создавать и редактировать карты, выгрузка их на сервер осуществляется из специального меню конструктора, которое будет доступно только для авторизованных пользователей. При планировании архитектуры сервиса, необходимо предусмотреть будущие развитие конструктора до публичной веб-версии, к которой будет иметь доступ любой желающий. Общее видение проекта подразумевает бизнес-модель аналогичную конструкторам сайтов, таким как Tilda или Wix. То есть, любой желающий сможет спроектировать карту, загрузить её на сервер и просмотреть, однако, для того, чтоб сделать её общедоступной, необходимо будет оплатить подписку.

Реализация веб-версии конструктора выходит за рамки текущий работы, однако планируется в дальнейших обновлениях сервиса, что накладывать ряд дополнительных требований на архитектуру:
- Весь процесс взаимодействия и обработки новых карт должен быть автоматизирован.
- Необходимо предусмотреть возможность добавления сервера синхронизации для совместной работы над одной картой.
- Необходимо заложить возможность масштабирования серверной части, отвечающей за обработку новых и изменения старых карт.

== Серверная часть
Сервис будет сталкиваться с неравномерной нагрузкой с высокими пиками, которые будут возникать в связи со следующими причинами:
- Повышенный спрос на карту университетов в начале учебного семестра
- Повышенный спрос на карту университетов в начале каждого дня. По утрам, в 10:00 и в 12:00, перед началом пар, студенты будут открывать карту, чтобы найти нужную аудиторию. Что подтверждается статистикой использования пилотной версии.
// TODO: Добавить график использования пилотной версии PolyMap
- При использовании карты на временных конференциях и выставках, большинство пользователей будут открывать карту одновременно, что создаст пиковую нагрузку на сервер.

Для решения этих проблем необходимо предусмотреть горизонтальное масштабирование серверной части, для этого был выбран микросервисных подход к разработке.

=== Микросервисы
Использование микросервисов позволит разделить приложение на независимые части, и те из них, на которые будет повышенная нагрузка, можно будет масштабировать отдельно от остальных.

Для полного покрытия функционала сервиса, необходимо разработать следующие микросервисы:
+ Сервис раздачи карт (`map-storage`) – заниматься раздачей файлов карты пользователям в зависимости от запроса.
+ Сервис обслуживания конструктора (`constructor-back`) – занимается обработкой запросов от конструктора карт, сохранять карты на сервер.
+ Сервис хранения бинарных объектов (`blob-storage`) – хранит бинарные объекты, которые можно будет размещать на карте (например кастомные изображения аннотаций, планы этажей и т.д.).
+ Сервис синхронизации совместного редактирования (`constructor-WS`) – используется для синхронизации совместного редактирования карты в реальном времени. Позволяет нескольким пользователям одновременно редактировать карту, и видеть изменения друг друга в реальном времени.
+ Сервис генерации приглашений (`share-back`) – используется для функции создания приглашений на маршрут, позволяет приложить к приглашению ещё и текстовое сообщение, которое будет отображаться в приложении при открытии приглашения.
+ Сервис генерации QR-кодов (`qr-generator`) – используется для функции создания QR-кода для функции "поделиться маршрутом". Функционал вынесен из клиента в серверно приложение, для того, чтобы в будущем можно было использовать его в нативных мобильных версиях.
+ Сервис раздачи фронтеда (`web-map-back`) – используется для генерации OpenGraph метаданных для index.html страницы карт.

Сервис хорошо подходит для реализации в микросервисной архитектуре, все микросервисы независимы друг от друга и могут работать обособленно.

#fig("Детальная схема архитектуры PolyMap", "../assets/polymap-architecture-big.pdf", width: 100%)<microservices>

== Serverless подход
Для оркестрации микросервисов наиболее распространено использовать Kubernetes, однако последние несколько лет, растёт популярность альтернативного подхода – Serverless. Он позволяет запускать и масштабировать микросервисы без необходимости взаимодействовать с виртуальными или выделенными серверами. Вместо этого, Serverless предлагает арендовать у облачных провайдеров только вычислительные ресурсы, которые фактически были использованы.

Основными недостатками Kubernetes выделают сложность настройки качественной инфраструктуры, высокий риск ошибок при ручной настройке, сложность управления версиями, а так же высокую стоимость кластера, особенно на начальных этапах разработки и тестовых средах.

=== Преимущества и недостатки
Как и любой другой подход, Serverless имеет свои плюсы и минусы. Плюсы Serverless вытекают из минусов Kubernetes:
+ Простота настройки и управления – при использовании Serverless, разработчик не взаимодействует с виртуальными серверами, а только с облачными ресурсами, которые предоставляют достаточно простой и однозначный интерфейс управления.
+ Низкая вероятность ошибок – так как разработчик не взаимодействует с виртуальными серверами, то вероятность ошибок при настройке инфраструктуры значительно снижается. Кроме того, облачные провайдеры предоставляют таки нестойки, которые не позволят допустить существенную ошибку.
+ Низкая стоимость – Serverless распространяется по модели pay-as-you-go, то есть необходимо оплачивать только те ресурсы, которые были фактически использованы, что хорошо видно на @serverless-vs-dedicated. Это позволяет значительно снизить затраты на инфраструктуру.

#fig(
  "Сравнение затрат на инфраструктуру",
  "../assets/serverless-vs-dedicated.pdf",
  width: 90%,
)<serverless-vs-dedicated>

За счёт того, что микросервисы в Serverless подходе запускаются только во время запроса пользователя и отключаются после завершения обработки, они потребляют ресурсы облака только в момент фактической работы, в отличии от Kubernetes, в котором вы арендуете виртуальные сервера вне зависимости от их использования. При переменно нагрузки, Kubernetes будет простаивать значительное время, что приведёт к нерациональным затратам, которых позволяет избежать Serverless.

Однако Serverless имеет и свои недостатки:
+ Требования читой архитектуры – Serverless подход требует от разработчиков строгого соблюдения принципов чистой архитектуры:
  - микросервисы быть независимыми друг от друга
  - связи должны быть сделаны через очереди сообщений
  - микросервисы должны быть State Less – то есть не должно храниться внутреннее состояние, оно будет потеряно при перезапуске микросервиса
+ Привязанность к облачному провайдеру – Serverless часть есть у большинства крупных облачных провайдеров, однако конечная реализация может отличаться, что сильно усложняет миграцию между облачными провайдерами.
+ Ограниченность возможностей – не любую микросервисную архитектуру удастся реализовать с помощью Serverless. Например, большинство баз данных не поддерживают Serverless. Однако облака предоставляют доступ к Managed версиям баз данных, к которым можно обращаться из Serverless микросервисов. Кроме того, не все технологии смогут корректно работать в условиях короткого жизненного цикла.
+ Должно быть обеспечено быстрое время холодного старта – так как микросервисы запускаются только во время запроса, то время их запуска должно быть минимальным. Это накладывает ограничения на используемые технологии, подробнее о выборе подходящего технологического стека рассмотрено в @serverless-technology-stack.

=== Cloud Native
В современном мире, для разработки и развёртывания приложений, всё чаще используется Cloud Native подход. Он подразумевает разработку приложений, которые будут работать в облаке, используя облачные ресурсы для хранения данных и вычислений. Это позволяет в некоторых аспектах упростить разработку и развёртывание приложений, а так же значительно снизить затраты на поддержку и гарантии доступности.

Serverless является дочерним подходом к Cloud Native разработке. Именно этот подход и был выбран для разработки серверной части приложения PolyMap.

=== Выбор облачного провайдера с применением СППР
Наиболее крупным игроком в сфере Serverless является Amazon Web Services (AWS), однако официально в России он не доступен, что создаёт дополнительные инфраструктурные риски. По этому, в качестве облачного провайдера необходимо было выбрать отечественную альтернативу.
На текущий момент в России существует несколько крупных облачных провайдеров предоставляющих Serverless решения:
- Яндекс Облако
- Selectel
- Сбер Облако

Для выбора облачного провайдера было принято решение воспользоваться системой поддержки принятия решений (СППР), которая позволяет сравнить облачные провайдеры по заданным критериям. В качестве критериев были выбраны следующие:
- Вычисления
- Интеграции
- БД, Очереди, Уведомления
- DevOps & DX
- Мониторинг, логи

Кроме отечественных облачных провайдеров, в таблице представлены и зарубежные:
- AWS – на текущий момент является лидером в области Serverless, однако официально недоступен в России.
- Google Cloud Platform – второй по популярности облачный провайдер, который активно развивает Serverless решения.
- Azure – облачный провайдер от Microsoft, в нём тоже присутствует Serverless, однако на нём не делают акцент.

Для всех критериев были проставлены оценки по шкале от 1 до 10, и с использованием 5 алгоритмов был рассчитан общий балл для каждого облачного провайдера. В @sppr-cloud-report находится подробный отчёт о работе СППР.

#figure(caption: [Результат работы СППР])[
  #show table.cell.where(y: 0): set text(weight: "bold")
  #table(
    columns: (auto, auto, auto, auto, auto, auto, auto, auto),
    align: horizon,
    table.header([Вариант], [Дом], [Блок], [Тур], [Sjp], [Sjm], [ИТОГО], [Место]),
    [*Yandex*], [5], [6], [5], [5], [6], [27], [3],
    [*Selectel*], [5], [6], [2], [2], [6], [21], [6],
    [*VK*], [5], [6], [1], [1], [6], [19], [7],
    [*Sber*], [5], [6], [3], [3], [6], [23], [5],
    [*AWS*], [7], [7], [7], [7], [7], [35], [1],
    [*Google*], [6], [6], [6], [6], [6], [30], [2],
    [*Azure*], [5], [6], [4], [4], [6], [25], [4],
  )
]<sppr-cloud-provider-result>

Как видно из таблицы #ref(<sppr-cloud-provider-result>, supplement: none), наибольшим требуемым функционалом обладает AWS, однако он, как и Google и Azure недоступны в России, наивысший балл среди отечественных сервисов получило Яндекс Облако, поэтому оно было выбрано в качестве облачного провайдера для проекта. Sber Cloud активно развивает свои Serverless решения, однако на момент написания работы, всё ещё сильно отставал от Яндекс Облака. Selectel и VK имеют очень урезанный Serverless функционал, который не позволяет реализовать проект в полном объёме.

=== Обзор Serverless компонентов Яндекс Облака
Подход к Serverless в Яндекс Облаке реализован с помощью следующих компонентов:
- Cloud Functions -- позволяет запускать код в ответ на события, такие как HTTP запросы или CRON задачи.
- Serverless Container -- позволяет запускать Docker контейнеры в ответ различные события.
- API Gateway -- позволяет описывать REST API для микросервисов в формате OpenAPI. Является публичной точкой входа в микросервисы.
- Message Queue -- позволяет организовать асинхронную связь между микросервисами. Совместим с Amazon SQS API.
- Yandex Data Base (YDB) -- Serverless база данных, которая может работать и в реляционном и в документо-ориентированном режимах. Совместимо DynamoDB API.
- Object Storage -- объектное хранилище, которое позволяет хранить и раздавать бинарные объекты по протоколу S3.
- Cloud Postbox -- сервис позволяет организовывать Email рассылки. Совместим с Amazon SES API.

В проекте не используется Cloud Functions, так как все микросервисы реализованы в виде Docker контейнеров, это позволяет использовать более привычный подход к разработке и тестированию, а так уменьшает привязанность к облачному провайдеру. Архитектура состоящая полностью из контейнеров может быть легко перенесена как на локальную машину, так и в другие облака. Кроме того, использование контейнеров позволяет использовать больший набор технологий, в том числе и те, которые не поддерживаются в Cloud Functions.

Кроме непосредственное Serverless компонентов, Яндекс Облако предоставляет и другие сервисы, которые будут полезны в проекте:
- Container Registry – позволяет хранить Docker образы, которые будут использоваться в Serverless Container.
- Monitoring – позволяет хранить и отслеживать состояния работы проекта: число запросов, время ответов и другие метрики. Кроме того, позволяет настраивать Alerting, который будет уведомлять о проблемах в работе проекта при срабатывании настроенных условий.
- Cloud Logging – позволяет собирать, хранить, фильтровать и просматривать логи из всех микросервисов в одном месте.

Yandex Cloud активно развивает Serverless раздел облака, и регулярно добавляет новые компоненты и улучшения. Например, на момент написания магистерской работы, в облако был добавлен Notification Service, который позволяет отправлять персональные уведомления пользователям через SMS, Push и Email. Это позволит в будущем расширить функционал сервиса PolyMap, сильно упростив реализацию личного кабинета заказчика.

=== Content Delivery Network (CDN)
Для решения задачи географического масштабирования, необходимо использовать Content Delivery Network (CDN) сети. Они пропускают запросы пользователей через географияески ближайший к ним узел, и в случае, если запрашиваемый ресурс разрешен для кеширования и уже есть в кеше, отдают его пользователю не перенаправляя запрос на основной сервер. Главным источником трафика в сервисе является раздача карт – это большие и тяжёлые файлы, которые будет скачивать каждый пользователь при каждом открытии карты. Сами карты являются статическими файлами, которые редко меняются, а так же, в большинстве случаев привязаны к конкретной локации. Поэтому их можно эффективно кешировать в CDN сети. Это позволит значительно снизить объём трафика и скорость открытия сайта, что положительно скажется на пользовательском опыте.

#fig("Схема работы CDN", "../assets/sheme-cdn.svg", width: 100%)<cdn>

Общий принцип работы CDN состоит в передаче DNS управления к CDN провайдеру, после чего, провайдер будет разрешать запросы к ближайшему узлу.

=== Жизненный цикл запроса
При использовании Serverless в Yandex Cloud, жизненный цикл обработки запросы выглядит следующим образом:
+ Пользователь через DNS сеть CDN определяет ближайший к нему узел, и отправляет запрос на него.
+ Узел CDN проверяет, есть ли запрашиваемый ресурс в кеше. Если он есть, то отдает его пользователю, если нет, то проксирует запрос в Yandex Cloud.
+ Yandex Cloud получает запрос и по домену находит соответствующий `API Gateway`, который будет обрабатывать запрос.
+ `API Gateway` проводит часть проверок (авторизацию, валидацию параметров) и перенаправляет запрос на соответствующий `Serverless Container`, который будет обрабатывать запрос.
+ Если нет запущенного экземпляра `Serverless Container`, то Yandex Cloud создаёт новый экземпляр контейнера из локального `Docker Registry`, и перенаправляет запрос на него.
+ `Serverless Container` обрабатывает запрос, при этом имеет возможность обращаться к прочим ресурсам Облака, таким как базы данных, очереди, и т.д.
+ После обработки запроса, `Serverless Container` возвращает ответ обратно в `API Gateway`, который в свою очередь возвращается к пользователю через CDN Proxy.
+ Если указаны заголовки кеширования, то CDN Proxy кеширует ответ на региональном узле, и в дальнейшем будет отдавать его пользователям, не перенаправляя запрос на основной сервер.

В случае обновления статического контента, есть возможность вызвать инвалидацию CDN кеша с помощью специального API. Это позволит удалить из кеша старую карту, чтобы новая версия была доступна пользователям сразу после обновления.

#fig("Жизненный цикл запроса", "../assets/request-lifecycle.pdf", width: 100%)<request-lifecycle>

=== Ценообразование
Основным преимуществом Serverless подхода является снижение инфраструктурных затрат относительно классических походов. Рассмотрим ценообразование в Yandex Cloud.

Важным фактором затрат на Serverless в Yandex Cloud является квоты на число бесплатно предоставляемых ресурсов. Эти квоты сбрасываются в начале каждого месяца, таким образом, низкая нагрузка в течение месяца, позволяет пользоваться инфраструктурой полностью бесплатно. После исчерпания квот, тарификация происходит по модели pay-as-you-go, то есть необходимо оплачивать только те ресурсы, которые были фактически использованы.

#include "../assets/serverless-price.typ"

=== Сравнение затрат на Serverless и Kubernetes

С использованием цен актуальных на момент написания работы (@serverless-price) можно ориентировочно рассчитать общие затраты на инфраструктуру в месяц. Возьмём ориентировочную нагрузку на пилотную версию PolyMap iOS (@polymap-ios-usage).

#include "../assets/polymap-ios-usage.typ"

Стоит отметить, что приложение не имеет официальный статус, и его не использовали для приглашений на мероприятия. В связи с этим, нагрузка на открытия приглашений сильно занижена, при реальном использовании на конференциях, число открытий приглашений будет пропорционально пришедшим пользователям.

Перенесём статистику на примерный механизм работы Serverless:
- API Gateway: 600 000 открытий карт + 70 000 просмотров аннотаций + 10 000 построений маршрутов + 250 открытий приглашений = 680 250 запросов
- Serverless Containers: 680 250 вызовов (среднее потребление: 0.5 ГБ памяти, 0.2 с процессора на вызов)
- Message Queue: 680 250 запросов
- Object Storage GET: 680 250 операций
- Исходящий трафик: ~600 000 загрузок карт по ~2 МБ = 1 200 ГБ

#include "../assets/serverless-polymap-cost.typ"

Как видно из расчёта (@polymap-serverless-cost) на самый нагруженный месяц – сентябрь, приблизительные затраты на Serverless инфраструктуру составят *1600 рублей*, и большая часть затрат это исходящий трафик, который порождается раздачей статичных файлов карты, однако, большинство этих запросов не будут доходить для серверов, а будут обрабатываться на узлах кеша CDN, по этому реальные затраты будут значительно ниже.

Сравним это с затратами на Kubernetes кластер. Так как нагрузка не очень высокая, возьмём минимальную production конфигурацию кластера, которая будет состоять из 3 нод с 4 vCPU и 4 ГБ RAM. Три ноды позволят обеспечить доступность и отказоустойчивость сервера, а 4 vCPU и 4 ГБ RAM будет достаточно для обработки аналогичной нагрузки. Такой кластер в Yandex Cloud будет стоить *33000 рублей* в месяц, что значительно выше, чем затраты на Serverless. Для сравнения, на @selectel есть стоимость минимально возможного кластера в Selectel, он имеет меньшую отказоустойчивость, так как находится в одной зоне доступности, однако обладает большими характеристиками: 8 vCPU и 16 ГБ RAM, такой кластер будет стоить *31000 рублей* в месяц.

#subfig(
  figure(image("../assets/kubernetes-price-yandex.png"), caption: [Yandex Cloud]),
  figure(image("../assets/kubernetes-price-selectel.png"), caption: [Selectel]),
  <selectel>,
  columns: (1fr, 0.65fr),
  caption: [Стоимость Kubernetes кластера в Yandex Cloud и Selectel],
)

Так же, не стоит забывать, что кроме production кластера, необходимо будет поддерживать тестовый кластер, для разработки и тестирования новых обновлений, что значительно увеличит затраты на инфрастуктуру, в то время, как в Serverless подходе, тестовые среды даже не будут выходить из бесплатных квот. За три года активной разработки, я ни разу не использовал больше 10% от выделенных квот, что позволяет полностью бесплатно разрабатывать и тестировать новые обновления.

= Реализация
== Система контроля версий
При разработке проекта в микросервисном подходе выделают два способа организации системы контроля версий:
+ Монорепозиторий – все микросервисы хранятся в одном репозитории. Плюсом этого подходя является сквозное версионирование всех микросервисов, каждый коммит порождает новую общую версию приложения, которая гарантирована не нарушит совместимость. Минусом такого подхода является сильная связанность между микросервисами, что усложняет их независимую разработку, тестирование и развёртывание.
+ Полирепозиторий – каждый микросервис хранится в своём репозитории. Плюсом такого подхода является независимость разработки, тестирования и развёртывания каждого микросервиса. Минусом такого подхода является сложность в управлении версиями. Может случиться так, что при обновление одного микросервиса сломается совместимость с другим.

Я выбрал второй подход, так как он лучше позволяет разделить кодовые базы и вести независимую разработку. Сложность версионирования решается гарантиями обратной совместимости – ни одна новая версия не должна ломать совместимость с предыдущими версиями. Это требование и так необходимо соблюдать, что бы корректно работало горизонтальное масштабирование, при котором в одним момент времени могут работать несколько версий одного микросервиса.

=== Выбор системы контроля версий

В качестве хранилища системы контроля версий Git можно использовать несколько систем:
- GitHub
- GitLab
- Bitbucket

Каждая из них обладает своими плюсами и минусам. Для выбора была составлена сравнительная таблица функционала, который потребуется для разработки проекта.

// TODO: Добавить сравнительную таблицу систем контроля версий

Как видно из таблицы, наибольшим числом плюсов обладает GitHub, поэтому он был выбран в качестве системы контроля версий для проекта.

В GitHub была создана отдельная огранизация, в которой хранятся все репозитории микросервисов проекта.
#fig("Организация Polymap в GitHub", "../assets/github-repo.jpg", width: 80%)<github-organization>


=== CI/CD
При разработке по микросервисной архитектуре крайне важно на самых ранних этапах автоматизировать процесс сборки и развёртывания приложения. Это обусловлено тем, что при таком подходе появляется множество проектов с частыми обновлениями, автоматизация рутинных процессов позволяет снизить количество ошибок, которые могут возникнуть при ручном развёртывании. А так же позволяет добавить автоматизированные тесты для контроля качества кода с самых ранних этапов.

=== GitHub Actions
В выбранной системе контроля версий GitHub, для автоматизации процессов сборки и развёртывания, используется встроенный инструмент GitHub Actions. С его помощью можно настроить различные автоматические процессы, которые будут запускаться при определённых действиях в репозитории. Процессы могут состоять из нескольких последовательных и параллельных шагов.

=== Infrastructure as Code (IAC)
Для автоматизации развёртывания приложений в CloudNative среде можно использовать IAC (Infrastructure as Code) подход. Он позволяет декларативно описать инфраструктуру в виде кода, который можно хранить рядом с кодом приложения в системе контроля версий. Это позволяет версионировать инфраструктуру вместе с кодом приложение, что в свою очередь позволяет откатить инфраструктуру к предыдущей версии, если в ней были внесены ошибки. Так же такой подход сильно упрощает развёртывание для Serverless приложений, который состоят из множества ресурсов, которые необходимо связать между собой.

=== Terraform
Для реализации IAC подхода наиболее популярным инструментом является Terraform. Все облачные провайдеры в первую очередь добавляют поддержку именно этого инструмента, в том числе и Yandex Cloud который используется в моём случае.

В Terraform инфраструктура описывается кодом на специальном языке HCL (HashiCorp Configuration Language). Базовой сущьностью в Terraform является ресурс, который описывает отдельный компонент инфраструктуры (Api GateWay, Serverless Container, Docker Registry). Внутри блока ресурса описываются его параметры. Внутри одного Terraform проекта можно ссылаться на другие ресурсы. Например, ресурс Serverless Container должен в своих параметрах ссылаться на ресурс Docker Registry, в котором хранится образ контейнера.

== Клиентская часть <web-map-implementation>
=== Vue
=== Three.js и WebGL
=== AppleMapKit
=== OpenGraphMeta

== Серверная часть
=== Стек технологий
// TODO: Указать что для Serverless круто использовать Bun
=== Выбор оптимальной технологии для Serverless <serverless-technology-stack>
=== Микросервисы
Рассмотрим некоторые микросервисы подробнее
=== Раздача карта и CDN



= Тестирование и оценка качества
// TODO: Папйплайн CI/CD
== Оценивание качества кода
== Модульное тестирование
== UI тестирование
== End to End тестирование
== Нагрузочное тестирование



= Заключение
// TODO: Анализ результатов
